"use strict";

const jsonpath = require("jsonpath");
const AuditLog = require("../auditlog.js");
const { DaoFactory } = require("uu_appg01_datastore");
const { LoggerFactory } = require("uu_appg01_core-logging");
const { ErrorConverter } = require("uu_appg01_core-appserver");
const {Config} = require("uu_appg01_core-utils");

// DefaultUcHandler has MIDDLEWARE_ORDER = -500, we put UuAuditLog between them
const MIDDLEWARE_ORDER = -550;

const SCHEMA_0_9_0 = "0.9.0";

class AuditLogMiddleware {

  constructor() {
    this.name = "uuAuditLog middleware";
    this.order = MIDDLEWARE_ORDER;
    this.isDataStoreOn = DaoFactory.isDataStoreOn();
    this.logger = LoggerFactory.get("AuditLogMiddleware");
    this.schemaVersion = AuditLog.getSchemaVersion();
    this.asid = Config.get("asid");
  }

  pre(req, res, next) {
    res.locals.auditLogStartTime = Date.now();

    return next();
  }

  ensure(req, res) {
    if (!this.isDataStoreOn) {
      return;
    }

    let ucProperties = res.locals.ucProperties;
    if (!ucProperties || Object.keys(ucProperties).length === 0) {
      return;
    } // TODO check whether it works like this on static resource calls

    let method = req.method.toUpperCase();
    let uri = res.locals.uri;
    let headers = req.headers;
    let session = res.locals.session;
    let authzResult = res.locals.authorizationResult;
    let dtoIn = res.locals.parsedParameters;
    let statusCode = res.statusCode;
    if (typeof statusCode === "string" || statusCode instanceof String) {
      statusCode = Number(statusCode);
    }
    let duration = Date.now() - res.locals.auditLogStartTime;
    let dtoOut = res.locals.response && res.locals.response.body;
    let error = res.locals.dispatchedError;

    this._logData(ucProperties, method, uri, headers, session, authzResult, dtoIn, statusCode, duration, dtoOut, error);
  }

  _parseDtoAuditMap(dtoAuditMap, dto) {
    if (!dtoAuditMap || !dto || !(typeof dto === "object")) {
      return null;
    }
    let result = {};
    for (let [key, path] of Object.entries(dtoAuditMap)) {
      try {
        let tmp = jsonpath.query(dto, path);
        if (tmp.length === 0) {
          // the expected value is not in dtoIn
          continue;
        }
        result[key] = tmp[0];
      } catch (e) {
        this.logger.warn(`The expected JSONPath string ${path} is invalid`, e);
      }
    }
    return result;
  }

  _logData(ucProperties, method, uri, headers, session, authzResult, dtoIn, statusCode, duration, dtoOut, error) {
    let severity, message, eventCode, ucState, errorDtoOut, errorCode, errorMessage;
    if (error) {
      let result = ErrorConverter.buildErrorDtoOut(error, true);
      errorDtoOut = result.dtoOut;
      errorCode = result.errorCode;
      errorMessage = result.errorMessage;
    }
    if (statusCode >= 500) {
      severity = "CRITICAL";
      message = errorMessage || "Use Case failed.";
      ucState = "completedWithError";
    } else if (statusCode >= 400) {
      severity = "ERROR";
      message = errorMessage || "Use Case failed.";
      ucState = "completedWithError";
    } else {
      severity = "INFO";
      message = "Use case executed.";
      ucState = "completed";
    }
    let clientIdentity = session.getClientIdentity();

    let parameters = {
      uri: uri.toString().replace(/\?.+/, ""),
      gateway: uri.getGateway(),
      forwardedFor: headers["x-forwarded-for"],
      tokenId: session.getId(),
      duration: duration,
      dtoInAuditMap: this._parseDtoAuditMap(ucProperties.getAttribute("dtoInAuditMap"), dtoIn),
      dtoOutAuditMap: this._parseDtoAuditMap(ucProperties.getAttribute("dtoOutAuditMap"), dtoOut),
    }
    if (headers["x-base-uri-alias"]) {
      parameters.baseUriAlias = headers["x-base-uri-alias"];
    }
    if (error) {
      parameters.errorCode = errorCode;
    }

    if (this.schemaVersion === SCHEMA_0_9_0) {
      eventCode = "UC_EXECUTION";
      parameters.ucStatus = statusCode;
      parameters.useCaseType = ucProperties.getType(),
      parameters.clientAppId = (clientIdentity && clientIdentity.getAwid()) || session.getAttribute("client_app_id");
      parameters.clientAppName = (clientIdentity && clientIdentity.getProduct()) || session.getAttribute("client_app_name");
      parameters.profileList = authzResult && authzResult.getAuthorizedProfiles();
    } else {
      eventCode = "uuApp/useCaseExecution";
      parameters.httpStatus = statusCode;
      parameters.httpMethod = method;
      parameters.useCaseState = ucState;
      parameters.useCaseType = ucProperties.getType() === "UVE" ? "uuUve" : "uuCmd";
      parameters.clientUuIdentity = clientIdentity && clientIdentity.getUuIdentity();
      parameters.clientUuIdentityType = clientIdentity && clientIdentity.getType();
      parameters.clientUuAppKey = session.getAttribute("client_uuappkey");
      parameters.authorizedProfileList = authzResult && authzResult.getAuthorizedProfiles();
      if (clientIdentity) {
        if (clientIdentity.getAuthenticationLevelOfAssurance() === "none") {
          parameters.callOrigin = "unknownApp";
        } else if (clientIdentity.getAwid() === uri.getAwid()) {
          parameters.callOrigin = "sameAwid";
        } else if (clientIdentity.getAsid() === this.asid) {
          parameters.callOrigin = "sameAsid";
        } else if (uri.getProduct().startsWith(clientIdentity.getProduct)) {
          parameters.callOrigin = "sameApp";
        } else {
          parameters.callOrigin = "differentApp";
        }
      } else {
        parameters.callOrigin = "unknownApp";
      }
      if (error) {
        parameters.errorId = error.id;
        parameters.uuAppErrorMap = JSON.stringify(errorDtoOut.uuAppErrorMap);
      }
    }

    AuditLog.log(severity, eventCode, message, parameters);
  }

}

module.exports = AuditLogMiddleware;
