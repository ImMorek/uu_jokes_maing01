/*!
 * Copyright (c) 2019 Unicorn a.s.
 * All rights reserved.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("module"), require("uu_appg01_core"));
	else if(typeof define === 'function' && define.amd)
		define("uu_appg01_oidc", ["module", "uu_appg01_core"], factory);
	else if(typeof exports === 'object')
		exports["uu_appg01_oidc"] = factory(require("module"), require("uu_appg01_core"));
	else
		root["UuApp"] = root["UuApp"] || {}, root["UuApp"]["Oidc"] = factory(root["undefined"], root["UuApp"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__6__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"index": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "chunks/uu_appg01_oidc/" + chunkId + "-" + "3324704d44aa1b413783" + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/ 				if (script.src.indexOf(window.location.origin + '/') !== 0) {
/******/ 					script.crossOrigin = "anonymous";
/******/ 				}
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["__webpack_jsonp_uu_appg01_oidc_3_7_5_uu_appg01_oidc"] = window["__webpack_jsonp_uu_appg01_oidc_3_7_5_uu_appg01_oidc"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var mod = __webpack_require__(2);
var isDoc = typeof document !== "undefined";
var uri = ((mod ? mod.uri : isDoc && (document.currentScript || Array.prototype.slice.call(document.getElementsByTagName("script"), -1)[0] || {}).src) || "").toString();
uri = uri.split(/\//).slice(0, -1).join("/") + "/"; // runtime publicPath configuration required for proper linking of styles, background images, ...
var floatingVersion = "/3.0.0/";
if (uri.substr(-floatingVersion.length) === floatingVersion) uri = uri.substr(0, uri.length - floatingVersion.length) + "/3.7.5/";
__webpack_require__.p = uri;
module.exports = __webpack_require__(3);
var ex = module.exports;
if (ex && _typeof(ex) === "object") {
  if (!("version" in ex)) ex.version = "3.7.5";
  if (!("name" in ex)) ex.name = "uu_appg01_oidc".split(/[\/\\]/).pop();
  if (!("namespace" in ex)) ex.namespace = "UuApp.Oidc";
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// polyfills for IE
if (!String.prototype.startsWith) {
  Object.defineProperty(String.prototype, 'startsWith', {
    value: function value(search, pos) {
      pos = !pos || pos < 0 ? 0 : +pos;
      return this.substring(pos, pos + search.length) === search;
    }
  });
}

// FIXME Copy&pasted src/index.js because following doesn't work (cyclic warning):
// module.exports = require("../index.server.js"); // with "../index.server.js" remapped back to src/index.js in package.json ("browser" field)
var sessionWrapped = false;
module.exports = {
  get AuthenticationService() {
    return __webpack_require__(4);
  },
  get Session() {
    var Session = __webpack_require__(25);
    if (!sessionWrapped) {
      sessionWrapped = true;
      __webpack_require__(42).wrapClass(Session, module.exports.AuthenticationService);
    }
    return Session;
  },
  get Internal() {
    return {
      get OAuthClient() {
        return __webpack_require__(11);
      },
      get AbstractAuthorizationFlow() {
        return __webpack_require__(29);
      },
      get ImplicitFlow() {
        return __webpack_require__(35);
      },
      get CodeFlow() {
        return __webpack_require__(36);
      }
    };
  },
  // Legacy names for backward compatibility with uu_oidcg01
  get OidcAuthenticationService() {
    return this.AuthenticationService;
  },
  get OidcSession() {
    return this.Session;
  }
};

// export to legacy variable too
if (!window.UuOidc) window.UuOidc = {
  Session: module.exports.Session
};

// bootstrap in browser
// extract access_token parameter and mask it in current URL (so that user does
// not accidentally copy&paste it to somebody else)
var callToken;
if (window.history && window.history.replaceState) {
  var accessTokenMatch = location.href.match(/[?&]?access_token=([^&#]+)/);
  if (accessTokenMatch) {
    callToken = accessTokenMatch[1];
    try {
      // NOTE Can't use native URL API because of IE 11...
      var maskedUrl = location.href.replace(/([?&])access_token=[^&#]*(&)?/, function (m, g1, g2) {
        return g2 ? g1 : "";
      });
      if (maskedUrl !== location.href) {
        history.replaceState(history.state, "", maskedUrl);
      }
    } catch (e) {
      // replacing state can fail - ignore in such case (e.g. when in <iframe srcdoc="..."></iframe>)
    }
  }
}

// Initialize authentication service in order for interactive authentication to work
// (wait until DOM is ready because we need BODY element to be present due to how implicit flow works)
var domReadyPromise;
if (document.readyState === "interactive" || document.readyState === "complete") {
  domReadyPromise = Promise.resolve();
} else {
  domReadyPromise = new Promise(function (resolve) {
    document.addEventListener("DOMContentLoaded", resolve, false);
  });
}
domReadyPromise.then(function () {
  module.exports.AuthenticationService._onPageLoad(callToken);
});

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(5),
  CoreAuthenticationService = _require.AuthenticationService,
  InvalidCredentials = _require.InvalidCredentials;
var _require2 = __webpack_require__(7),
  Config = _require2.Config,
  BaseError = _require2.BaseError;
var _require3 = __webpack_require__(8),
  LoggerFactory = _require3.LoggerFactory;
var _require4 = __webpack_require__(9),
  AppClient = _require4.AppClient;
var DefaultServiceLoader = __webpack_require__(10);
var OAuthClient = __webpack_require__(11);
var Session = __webpack_require__(25);
var AbstractAuthorizationFlow = __webpack_require__(29);
var ImplicitFlow = __webpack_require__(35);
var CodeFlow = __webpack_require__(36);
var CodeFlowV2 = __webpack_require__(37);
var Os8Flow = __webpack_require__(38);
var ClientCredentialsProvider = __webpack_require__(27);
var SessionStateChangeNotifier = __webpack_require__(39);
var BrowserSession = __webpack_require__(40);
var Dom = __webpack_require__(28);
var InteractionRequired = __webpack_require__(34);
var META_SERVICE_NAME = "uu_appg01_oidc";
var CONFIG_REQUESTED_ACR_VALUES = "uu_app_oidc_requested_acr_values";
var CONFIG_MAX_AUTHENTICATION_AGE = "uu_app_oidc_max_authentication_age";
var CONFIG_PREFIX = "uu_app_oidc_providers_";
var SECONDARY_PROVIDERS_ENABLED_CFG = "uu_app_oidc_secondary_providers_enabled";
var CONFIG_REDIRECT_URI_KEY = "uu_app_oidc_redirect_uri";
var CONFIG_AUTHN_FLOW_OVERRIDE = "uu_app_oidc_authn_flow_override";
var CONFIG_BACKEND_AVAILABLE = "uu_app_oidc_backend_available";
var CONFIG_BACKEND_GRANT_CALL_TOKEN_AVAILABLE = "uu_app_oidc_backend_grant_call_token_available";
var DEFAULT_AUTHN_TYPE = "implicit";
var DEFAULT_CROSSDOMAIN_STRATEGY = "cookie";
var DEFAULT_SCOPE_MODE = "baseUri";
var RESTORE_SESSION_DISABLED = "disabled";
var FORWARD_CROSSDOMAIN_STRATEGY = "forward";
var JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;

/**
 * Frontend implementation of authentication service based on uuOIDC.
 */
var AuthenticationService = /*#__PURE__*/function () {
  /**
   * Creates new instance of uuOIDC authentication service.
   * @param {String} name Service name
   * @param {Object|null} opts Service options
   * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
   * @param {number} options.tokenCacheSize Maximal size of call token cache
   * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
   */
  function AuthenticationService(name) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, AuthenticationService);
    if (!name) {
      throw new BaseError("Service name is not defined");
    }
    this._serviceName = name;
    this._serviceUri = opts.serviceUri;
    if (!this._serviceUri) {
      throw new BaseError("There is no service URI defined for service ".concat(this._serviceName));
    }
    this._oauthClient = null;
    this._loadOauthClientPromise = this._loadOauthClient(this._serviceName, this._serviceUri, opts);
    this._callTokenType = opts.callTokenType;
    this._emptySession = BrowserSession.from(Session._createEmptySession(), undefined, undefined, undefined, undefined, this);
    this._currentSession = this._emptySession;
    this._runningAuthnPromise = null;
    this._restoreSessionPromise = null;
    this._isRestoringSession = false;
    this._listeners = [];
    this._globalSessionExpiring = false;
    this._defaultAcrValues = Config.getString(CONFIG_REQUESTED_ACR_VALUES, false) || "low standard high veryHigh";
    this._defaultMaxAge = Config.getNumber(CONFIG_MAX_AUTHENTICATION_AGE, false);
    this._defaultScopeMode = Config.getString(CONFIG_PREFIX + this._serviceName + "_default_call_token_scope_mode") || DEFAULT_SCOPE_MODE;
    this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
    this._redirectUri = Dom.toFullAppUrl(Config.getString(CONFIG_REDIRECT_URI_KEY) || "/oidc/callback");
    this._authnFlow = null;
    this._loadAuthnFlowPromise = this._loadAuthnFlow();
    this._autoLogoutSupportInitialized = false;
    this._autoTokenRefreshInitialized = false;
    this._sessionExtendedAndExpiringSupportInitialized = false;
    this._sessionStateChangeNotifierInitialized = false;
  }

  /**
   * Returns name of authentication service
   * @returns {String} Name of authentication service
   */
  _createClass(AuthenticationService, [{
    key: "getServiceName",
    value: function getServiceName() {
      return this._serviceName;
    }

    /**
     * Returns URI of authentication service
     * @returns {String} URI of authentication service
     */
  }, {
    key: "getServiceUri",
    value: function () {
      var _getServiceUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this._oauthClient) {
                _context.next = 3;
                break;
              }
              _context.next = 3;
              return this._loadOauthClientPromise;
            case 3:
              _context.next = 5;
              return this._oauthClient.getIssuerList();
            case 5:
              return _context.abrupt("return", _context.sent[0]);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getServiceUri() {
        return _getServiceUri.apply(this, arguments);
      }
      return getServiceUri;
    }()
    /**
     * Returns URI of authentication service.
     * @returns {String|Uri|*} URI of authentication service
     * @deprecated
     */
  }, {
    key: "getProviderUri",
    value: function getProviderUri() {
      return this._serviceUri;
    }

    /**
     * Returns current session or null if the user is not logged in.
     * @returns {Session} Current session or null if the user is not logged in.
     */
  }, {
    key: "getCurrentSession",
    value: function getCurrentSession() {
      return this._currentSession;
    }

    /**
     * Restores session, i.e. checks whether to user is logged in on remote server
     * and initializes session if (s)he is.
     * @param {Object|null} options Options
     * @param {String} options.acrValues Requested authentication level
     * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
     * @returns {Promise<Session>} Promise resolved when session restoration ends. In case of failure
     *   the promise is still resolved successfully but with null.
     */
  }, {
    key: "restoreSession",
    value: function () {
      var _restoreSession2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _this = this;
        var options,
          _ref,
          acrValues,
          maxAge,
          callToken,
          clientId,
          session,
          restoreSessionFn,
          restoreSessionArgs,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              if (this._restoreSessionPromise) {
                _context2.next = 11;
                break;
              }
              this._isRestoringSession = true;
              this._logger.debug("Trying to restore session for ".concat(this.getServiceName(), "."));
              _ref = options || {}, acrValues = _ref.acrValues, maxAge = _ref.maxAge, callToken = _ref.callToken;
              _context2.next = 7;
              return ClientCredentialsProvider.getClientId(this._serviceName);
            case 7:
              clientId = _context2.sent;
              session = BrowserSession.loadFromCache(this, clientId);
              if (session && session.matches(acrValues || this._defaultAcrValues, maxAge || this._defaultMaxAge)) {
                this._logger.debug("Session for ".concat(this.getServiceName(), " loaded from cache."));
                restoreSessionFn = this._authenticateBySession.bind(this);
                restoreSessionArgs = session;
              } else if (callToken) {
                this._logger.warn("Trying to initialize session by access_token for ".concat(this.getServiceName(), ". This method is deprecated and is going to be removed!"));
                restoreSessionFn = this._authenticateByCallToken.bind(this);
                restoreSessionArgs = callToken;
              } else {
                restoreSessionFn = this._restoreSession.bind(this);
                restoreSessionArgs = {
                  acrValues: acrValues,
                  maxAge: maxAge
                };
              }
              this._restoreSessionPromise = restoreSessionFn(restoreSessionArgs).then(function (r) {
                _this._logger.debug("Session for ".concat(_this.getServiceName(), " restored."));
                _this._isRestoringSession = false;
                return r;
              }, function (e) {
                if (e && (e.code && e.code.match(/(interaction|login|account_selection|consent)_required/i) || e.message && e.message.match(/interaction required/i))) {
                  _this._logger.debug("Restore of session for ".concat(_this.getServiceName(), " failed, user interaction is required (").concat(e.code, ")."));
                } else {
                  _this._logger.error("Restore of session for ".concat(_this.getServiceName(), " failed."), e);
                }
                _this._isRestoringSession = false;
                return _this._currentSession;
              });
            case 11:
              return _context2.abrupt("return", this._restoreSessionPromise);
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function restoreSession() {
        return _restoreSession2.apply(this, arguments);
      }
      return restoreSession;
    }()
    /**
     * Returns whether the session is in process of being restored.
     * @returns {boolean} Whether the session is in process of being restored.
     */
  }, {
    key: "isRestoringSession",
    value: function isRestoringSession() {
      return this._isRestoringSession;
    }

    /**
     * Invokes immediate session check.
     * @param {Boolean} forceSessionExtend Flag whether check should be done via explicit extension of session.
     * @returns {null} Result of check is propagated to attached listeners.
     */
  }, {
    key: "checkSession",
    value: function checkSession() {
      var forceSessionExtend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (forceSessionExtend && this._currentSession && this._currentSession.isAuthenticated()) {
        this._silentTokenRefresh(true);
      } else if (this._sessionChecker) {
        this._sessionChecker._checkState();
      }
      return null;
    }

    /**
     * Authenticates user (using primary authentication service).
     * @param {Object|null} options Options
     * @param {Object} options.authenticationContext Custom object for persisting application state during authentication process (passed context is returned
     *                   when user is sucessfully authenticated allowing application to continue with its flow which was interrupted by authentication)
     * @param {String} options.acrValues Requested authentication level
     * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
     * @param {String} options.prompt One of null (show login page if not authenticated), "login" (show login page regardless of authentication state), "none" (silently
     *                   find out authentication state) and "registration" (shows registration page instead of login form).
     * @param {String} options.language What language the login page should use.
     * @param {String} options.os8Token Authenticates the user using uuOS8 token.
     * @param {Boolean} options.usePopup Flag if login form should be displayed in popup (default) or in main application window.
     * @param {String} options.scopeMode Scope mode (one of [useCase, allUseCases, baseUri, none]). Applied only if scope is not explicitly set.
     * @param {String} options.loginHint Optional identification of user which we want to authenticate (usable with prompt "login" and "registration")
     * @param {String} scope Scope allows for limitations of where resulting session can be used (defaults to application baseUri unless scope mode is set to "none").
     * @returns {Promise<Session>} User session for authenticated user.
     */
  }, {
    key: "authenticate",
    value: function () {
      var _authenticate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
        var scope,
          uiComponent,
          flow,
          scopeMode,
          result,
          supportedAcrValues,
          session,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              scope = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;
              if (!(this._runningAuthnPromise && this._equalsArray(this._runningAuthnArgs, Array.prototype.slice.call(_args3)))) {
                _context3.next = 5;
                break;
              }
              uiComponent = this._runningAuthnPromise.uiComponent;
              if (uiComponent && typeof uiComponent.focus === "function") uiComponent.focus();
              return _context3.abrupt("return", this._runningAuthnPromise);
            case 5:
              if (this._oauthClient) {
                _context3.next = 8;
                break;
              }
              _context3.next = 8;
              return this._loadOauthClientPromise;
            case 8:
              if (!(options && options.os8Token)) {
                _context3.next = 12;
                break;
              }
              flow = new Os8Flow(this._oauthClient, this._serviceName, this._redirectUri);
              _context3.next = 16;
              break;
            case 12:
              if (this._authnFlow) {
                _context3.next = 15;
                break;
              }
              _context3.next = 15;
              return this._loadAuthnFlowPromise;
            case 15:
              flow = this._authnFlow;
            case 16:
              scopeMode = options && options.scopeMode ? options.scopeMode : this._defaultScopeMode;
              if ((!scope || scope.length == 0) && scopeMode !== "none") {
                scope = Dom.canonicalAppBaseUri || Dom.appBaseUri;
                scope = scope.replace(/\/$/, "");
              }
              _context3.prev = 18;
              this._runningAuthnArgs = Array.prototype.slice.call(_args3);
              this._runningAuthnPromise = flow.authenticate(options, scope);
              _context3.next = 23;
              return this._runningAuthnPromise;
            case 23:
              result = _context3.sent;
              _context3.next = 26;
              return this._oauthClient.getSupportedAcrValues();
            case 26:
              supportedAcrValues = _context3.sent;
              session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, result.claims, result.idToken, result.accessToken);
              session = BrowserSession.from(session, result.authenticationContext, result.globalSessionExpiresAt, result.globalSessionState, this);
              session._authConstraints = {
                scope: result.scope,
                acrValues: result.acrValues,
                maxAge: result.maxAge
              };
              this._currentSession = session;
              this._initHandlers();
              if (session) {
                session._onCloseListener = this._onSessionClose.bind(this);
                session.storeToCache(result.clientId);
              }
              this._triggerEvent("sessionChanged", session);
              return _context3.abrupt("return", session);
            case 35:
              _context3.prev = 35;
              this._runningAuthnArgs = [];
              this._runningAuthnPromise = null;
              return _context3.finish(35);
            case 39:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[18,, 35, 39]]);
      }));
      function authenticate(_x) {
        return _authenticate.apply(this, arguments);
      }
      return authenticate;
    }()
    /**
     * Returns whether an authentication is in progress.
     * @returns {boolean} Whether an authentication is in progress.
     */
  }, {
    key: "isAuthenticating",
    value: function isAuthenticating() {
      return !!this._runningAuthnPromise;
    }

    /**
     * Adds listener for specified event. Listener is a function accepting an event object, which contains following fields:
     *
     * * **type** The type of the event, e.g. "sessionChanged".
     * * **data** The data passed to the event.
     * @param {string} eventType The event to register listener for.
     * @param {function(Event)} listenerFn The function to be called whenever the event is trigerred.
     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link #removeListener}).
     */
  }, {
    key: "addListener",
    value: function addListener(eventType, listenerFn) {
      var list = this._listeners[eventType];
      if (!list) list = this._listeners[eventType] = [];
      list.push(listenerFn);
      return this.removeListener.bind(this, eventType, listenerFn);
    }

    /**
     * Removes listener for specified event.
     * @param {string} eventType The event to remove listener for.
     * @param {function(Event)} listenerFn The listener (function) to unregister.
     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
     */
  }, {
    key: "removeListener",
    value: function removeListener(eventType, listenerFn) {
      var list = this._listeners[eventType];
      if (!list) return false;
      var idx = list.indexOf(listenerFn);
      if (idx != -1) list.splice(idx, 1);
      return idx != -1;
    }

    /**
     * Returns whether the user (global) session is expiring.
     * @returns {boolean} Whether the user (global) session is expiring.
     */
  }, {
    key: "isSessionExpiring",
    value: function isSessionExpiring() {
      return this._globalSessionExpiring;
    }

    // ======================== Private methods ================================
  }, {
    key: "_loadAsyncData",
    value: function () {
      var _loadAsyncData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (this._oauthClient) {
                _context4.next = 3;
                break;
              }
              _context4.next = 3;
              return this._loadOauthClientPromise;
            case 3:
              _context4.next = 5;
              return this._oauthClient.getMetadata();
            case 5:
              _context4.next = 7;
              return ClientCredentialsProvider.getClientId(this._serviceName);
            case 7:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function _loadAsyncData() {
        return _loadAsyncData2.apply(this, arguments);
      }
      return _loadAsyncData;
    }()
  }, {
    key: "_loadOauthClient",
    value: function () {
      var _loadOauthClient2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(serviceName, serviceUri, opts) {
        var mtlsEnabled, customOauthRealization;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              mtlsEnabled = Config.getBoolean(CONFIG_PREFIX + serviceName + "_mtls_enabled", false);
              if (mtlsEnabled) {
                opts["mtlsGateway"] = Config.get(CONFIG_PREFIX + serviceName + "_mtls_gateway");
              }
              customOauthRealization = Config.get(CONFIG_PREFIX + serviceName + "_oauth_frontend_realization");
              if (!customOauthRealization) {
                _context5.next = 25;
                break;
              }
              if (!(typeof customOauthRealization === "string")) {
                _context5.next = 14;
                break;
              }
              _context5.prev = 5;
              _context5.next = 8;
              return SystemJS.import(customOauthRealization);
            case 8:
              customOauthRealization = _context5.sent;
              _context5.next = 14;
              break;
            case 11:
              _context5.prev = 11;
              _context5.t0 = _context5["catch"](5);
              throw new BaseError("Unable to load custom oauth realization.", _context5.t0);
            case 14:
              if (!(typeof customOauthRealization === "function")) {
                _context5.next = 18;
                break;
              }
              this._oauthClient = new customOauthRealization(serviceUri, opts);
              _context5.next = 23;
              break;
            case 18:
              if (!(_typeof(customOauthRealization) === "object")) {
                _context5.next = 22;
                break;
              }
              this._oauthClient = customOauthRealization;
              _context5.next = 23;
              break;
            case 22:
              throw new BaseError("Oauth realization '".concat(customOauthRealization, "' is not supported."));
            case 23:
              _context5.next = 26;
              break;
            case 25:
              this._oauthClient = new OAuthClient(serviceUri, opts);
            case 26:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[5, 11]]);
      }));
      function _loadOauthClient(_x2, _x3, _x4) {
        return _loadOauthClient2.apply(this, arguments);
      }
      return _loadOauthClient;
    }()
  }, {
    key: "_loadAuthnFlow",
    value: function () {
      var _loadAuthnFlow2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var authnFlowOverride, authenticationType, crossdomainStrategy, backendAvailable;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (this._oauthClient) {
                _context6.next = 3;
                break;
              }
              _context6.next = 3;
              return this._loadOauthClientPromise;
            case 3:
              authnFlowOverride = Config.get(CONFIG_AUTHN_FLOW_OVERRIDE);
              if (!authnFlowOverride) {
                _context6.next = 26;
                break;
              }
              if (!(typeof authnFlowOverride === "string")) {
                _context6.next = 15;
                break;
              }
              _context6.prev = 6;
              _context6.next = 9;
              return SystemJS.import(authnFlowOverride);
            case 9:
              authnFlowOverride = _context6.sent;
              _context6.next = 15;
              break;
            case 12:
              _context6.prev = 12;
              _context6.t0 = _context6["catch"](6);
              throw new BaseError("Unable to load authentication flow override.", _context6.t0);
            case 15:
              if (!(typeof authnFlowOverride === "function")) {
                _context6.next = 19;
                break;
              }
              this._authnFlow = new authnFlowOverride(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
              _context6.next = 24;
              break;
            case 19:
              if (!(_typeof(authnFlowOverride) === "object")) {
                _context6.next = 23;
                break;
              }
              this._authnFlow = authnFlowOverride;
              _context6.next = 24;
              break;
            case 23:
              throw new BaseError("Authentication flow override '".concat(authnFlowOverride, "' is not supported."));
            case 24:
              _context6.next = 40;
              break;
            case 26:
              authenticationType = Config.getString(CONFIG_PREFIX + this._serviceName + "_authentication_type") || DEFAULT_AUTHN_TYPE;
              crossdomainStrategy = Config.getString(CONFIG_PREFIX + this._serviceName + "_session_crossdomain_strategy") || DEFAULT_CROSSDOMAIN_STRATEGY;
              backendAvailable = Config.getBoolean(CONFIG_BACKEND_AVAILABLE);
              if (authenticationType === "code" && !backendAvailable) {
                this._logger.warn("Authentication type [code] requested, but no comatible backend found. Switching to [implicit].");
                authenticationType = "implicit";
              }
              if (!(authenticationType === "implicit")) {
                _context6.next = 35;
                break;
              }
              if (crossdomainStrategy === FORWARD_CROSSDOMAIN_STRATEGY) {
                this._logger.warn("Session crossdomain strategy set to [forward] which is not supported by authentication type [implicit]. Configuration is ignored.");
              }
              this._authnFlow = new ImplicitFlow(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
              _context6.next = 40;
              break;
            case 35:
              if (!(authenticationType === "code")) {
                _context6.next = 39;
                break;
              }
              if (crossdomainStrategy === FORWARD_CROSSDOMAIN_STRATEGY) {
                if (Config.getBoolean(CONFIG_BACKEND_GRANT_CALL_TOKEN_AVAILABLE)) {
                  this._authnFlow = new CodeFlowV2(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
                } else {
                  this._logger.warn("Session crossdomain strategy set to [forward] which is not supported by application backend. Configuration is ignored.");
                  this._authnFlow = new CodeFlow(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
                }
              } else {
                this._authnFlow = new CodeFlow(this._oauthClient, this._serviceName, this._redirectUri, Dom.appBaseUri);
              }
              _context6.next = 40;
              break;
            case 39:
              throw new BaseError("Authentication type '".concat(authenticationType, "' is not supported."));
            case 40:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[6, 12]]);
      }));
      function _loadAuthnFlow() {
        return _loadAuthnFlow2.apply(this, arguments);
      }
      return _loadAuthnFlow;
    }()
  }, {
    key: "_restoreSession",
    value: function () {
      var _restoreSession3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(options) {
        var uiComponent,
          flow,
          scopeMode,
          scope,
          result,
          supportedAcrValues,
          session,
          _args7 = arguments;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!(this._runningAuthnPromise && this._equalsArray(this._runningAuthnArgs, Array.prototype.slice.call(_args7)))) {
                _context7.next = 4;
                break;
              }
              uiComponent = this._runningAuthnPromise.uiComponent;
              if (uiComponent && typeof uiComponent.focus === "function") uiComponent.focus();
              return _context7.abrupt("return", this._runningAuthnPromise);
            case 4:
              if (this._oauthClient) {
                _context7.next = 7;
                break;
              }
              _context7.next = 7;
              return this._loadOauthClientPromise;
            case 7:
              if (!(options && options.os8Token)) {
                _context7.next = 11;
                break;
              }
              flow = new Os8Flow(this._oauthClient, this._serviceName, this._redirectUri);
              _context7.next = 15;
              break;
            case 11:
              if (this._authnFlow) {
                _context7.next = 14;
                break;
              }
              _context7.next = 14;
              return this._loadAuthnFlowPromise;
            case 14:
              flow = this._authnFlow;
            case 15:
              scopeMode = options && options.scopeMode ? options.scopeMode : this._defaultScopeMode;
              if (scopeMode !== "none") {
                scope = Dom.canonicalAppBaseUri || Dom.appBaseUri;
                scope = scope.replace(/\/$/, "");
              }
              _context7.prev = 17;
              this._runningAuthnArgs = Array.prototype.slice.call(_args7);
              if (flow.restoreSession) {
                this._runningAuthnPromise = flow.restoreSession(options, scope);
              } else {
                options = _objectSpread({
                  prompt: "none"
                }, options);
                this._runningAuthnPromise = flow.authenticate(options, scope);
              }
              _context7.next = 22;
              return this._runningAuthnPromise;
            case 22:
              result = _context7.sent;
              _context7.next = 25;
              return this._oauthClient.getSupportedAcrValues();
            case 25:
              supportedAcrValues = _context7.sent;
              session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, result.claims, result.idToken, result.accessToken);
              session = BrowserSession.from(session, result.authenticationContext, result.globalSessionExpiresAt, result.globalSessionState, this);
              session._authConstraints = {
                scope: result.scope,
                acrValues: result.acrValues,
                maxAge: result.maxAge
              };
              this._currentSession = session;
              this._initHandlers();
              if (session) {
                session._onCloseListener = this._onSessionClose.bind(this);
                session.storeToCache(result.clientId);
              }
              this._triggerEvent("sessionChanged", session);
              return _context7.abrupt("return", session);
            case 34:
              _context7.prev = 34;
              this._runningAuthnArgs = [];
              this._runningAuthnPromise = null;
              return _context7.finish(34);
            case 38:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[17,, 34, 38]]);
      }));
      function _restoreSession(_x5) {
        return _restoreSession3.apply(this, arguments);
      }
      return _restoreSession;
    }()
  }, {
    key: "_authenticateBySession",
    value: function () {
      var _authenticateBySession2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(session) {
        var mockRunningAuthPromise;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              mockRunningAuthPromise = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
                return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                  while (1) switch (_context8.prev = _context8.next) {
                    case 0:
                      _context8.next = 2;
                      return ClientCredentialsProvider.getClientId(this._serviceName);
                    case 2:
                      if (this._oauthClient) {
                        _context8.next = 5;
                        break;
                      }
                      _context8.next = 5;
                      return this._loadOauthClientPromise;
                    case 5:
                      _context8.next = 7;
                      return this._oauthClient.getSupportedAcrValues();
                    case 7:
                      return _context8.abrupt("return", {
                        session: session,
                        authCtx: session.getAuthenticationContext(),
                        globalSessionExpiresAt: session.getExpiresAt(),
                        globalSessionState: session.getState()
                      });
                    case 8:
                    case "end":
                      return _context8.stop();
                  }
                }, _callee8, this);
              })).bind(this);
              _context9.prev = 1;
              this._runningAuthnPromise = mockRunningAuthPromise();
              _context9.next = 5;
              return this._runningAuthnPromise;
            case 5:
              this._currentSession = session;
              this._initHandlers();
              if (session) {
                session._onCloseListener = this._onSessionClose.bind(this);
              }
              this._triggerEvent("sessionChanged", session);
              return _context9.abrupt("return", session);
            case 10:
              _context9.prev = 10;
              this._runningAuthnArgs = [];
              this._runningAuthnPromise = null;
              return _context9.finish(10);
            case 14:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[1,, 10, 14]]);
      }));
      function _authenticateBySession(_x6) {
        return _authenticateBySession2.apply(this, arguments);
      }
      return _authenticateBySession;
    }()
  }, {
    key: "_authenticateByCallToken",
    value: function () {
      var _authenticateByCallToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(callToken) {
        var mockRunningAuthPromise, _yield$this$_runningA, session;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              mockRunningAuthPromise = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                var claims, idToken, accessToken, appClient, headers, params, supportedIssuers, supportedAcrValues, session;
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) switch (_context12.prev = _context12.next) {
                    case 0:
                      if (this._oauthClient) {
                        _context12.next = 3;
                        break;
                      }
                      _context12.next = 3;
                      return this._loadOauthClientPromise;
                    case 3:
                      if (!callToken.match(JWT_TOKEN_REGEX)) {
                        _context12.next = 10;
                        break;
                      }
                      _context12.next = 6;
                      return this._oauthClient.parseToken(callToken, this._callTokenType);
                    case 6:
                      claims = _context12.sent;
                      if (this._callTokenType === "idToken") {
                        idToken = callToken;
                        accessToken = null;
                      } else if (this._callTokenType === "accessToken") {
                        idToken = null;
                        accessToken = callToken;
                      } else {
                        // uuOidc by default uses JWT format only for idToken
                        idToken = callToken;
                        accessToken = null;
                      }
                      _context12.next = 17;
                      break;
                    case 10:
                      appClient = new AppClient({
                        baseUri: Dom.canonicalAppBaseUri || Dom.appBaseUri
                      });
                      headers = {
                        authorization: "Bearer ".concat(callToken)
                      };
                      params = {
                        _: Date.now()
                      }; // cache buster parameter
                      _context12.next = 15;
                      return appClient.get("oidc/introspect", params, {
                        headers: headers
                      });
                    case 15:
                      claims = _context12.sent.data;
                      if (this._callTokenType === "idToken") {
                        idToken = callToken;
                        accessToken = null;
                      } else if (this._callTokenType === "accessToken") {
                        idToken = null;
                        accessToken = callToken;
                      } else {
                        // uuOidc by default uses JWT format only for idToken
                        idToken = null;
                        accessToken = callToken;
                      }
                    case 17:
                      _context12.next = 19;
                      return this._oauthClient.getIssuerList();
                    case 19:
                      supportedIssuers = _context12.sent;
                      if (supportedIssuers.includes(claims.iss)) {
                        _context12.next = 22;
                        break;
                      }
                      throw new InvalidCredentials("Token is not trusted (unknown token issuer).");
                    case 22:
                      _context12.next = 24;
                      return ClientCredentialsProvider.getClientId(this._serviceName);
                    case 24:
                      _context12.next = 26;
                      return this._oauthClient.getSupportedAcrValues();
                    case 26:
                      supportedAcrValues = _context12.sent;
                      // Prepare session instance
                      session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, claims, idToken, accessToken);
                      session = BrowserSession.from(session, null, null, null, null, this);
                      // Override session.getCallToken() to return only token it was initialized with
                      session.getCallToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                        var scope,
                          opts,
                          token,
                          excludeAuthType,
                          _args10 = arguments;
                        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                          while (1) switch (_context10.prev = _context10.next) {
                            case 0:
                              scope = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : null;
                              opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
                              token = this._idToken || this._accessToken;
                              if (!token) {
                                _context10.next = 12;
                                break;
                              }
                              excludeAuthType = opts ? opts.excludeAuthenticationType : false;
                              if (!(excludeAuthType === true)) {
                                _context10.next = 9;
                                break;
                              }
                              return _context10.abrupt("return", token);
                            case 9:
                              return _context10.abrupt("return", "Bearer ".concat(token));
                            case 10:
                              _context10.next = 13;
                              break;
                            case 12:
                              return _context10.abrupt("return", null);
                            case 13:
                            case "end":
                              return _context10.stop();
                          }
                        }, _callee10, this);
                      })).bind(session);
                      // Override session.close() to do not invoke remote logout
                      session.close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                          while (1) switch (_context11.prev = _context11.next) {
                            case 0:
                              this.removeFromCache();
                              if (this._authenticated && typeof this._onCloseListener === "function") {
                                this._onCloseListener(this);
                              }
                              this._authenticated = false;
                              this._idToken = null;
                              this._accessToken = null;
                            case 5:
                            case "end":
                              return _context11.stop();
                          }
                        }, _callee11, this);
                      })).bind(session);
                      return _context12.abrupt("return", {
                        session: session
                      });
                    case 32:
                    case "end":
                      return _context12.stop();
                  }
                }, _callee12, this);
              })).bind(this);
              _context13.prev = 1;
              this._runningAuthnPromise = mockRunningAuthPromise();
              _context13.next = 5;
              return this._runningAuthnPromise;
            case 5:
              _yield$this$_runningA = _context13.sent;
              session = _yield$this$_runningA.session;
              this._currentSession = session;
              if (session) {
                session._onCloseListener = this._onSessionClose.bind(this);
              }
              this._triggerEvent("sessionChanged", session);
              return _context13.abrupt("return", session);
            case 11:
              _context13.prev = 11;
              this._runningAuthnArgs = [];
              this._runningAuthnPromise = null;
              return _context13.finish(11);
            case 15:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this, [[1,, 11, 15]]);
      }));
      function _authenticateByCallToken(_x7) {
        return _authenticateByCallToken2.apply(this, arguments);
      }
      return _authenticateByCallToken;
    }()
  }, {
    key: "_initHandlers",
    value: function _initHandlers() {
      if (!this._autoLogoutSupportInitialized) {
        this._initAutoLogoutSupport();
        this._autoLogoutSupportInitialized = true;
      }
      if (!this._autoTokenRefreshInitialized) {
        this._initAutoTokenRefresh();
        this._autoTokenRefreshInitialized = true;
      }
      if (!this._sessionExtendedAndExpiringSupportInitialized) {
        this._initSessionExtendedAndExpiringSupport();
        this._sessionExtendedAndExpiringSupportInitialized = true;
      }
      if (!this._sessionStateChangeNotifierInitialized) {
        this._initSessionStateChangeNotifier();
        this._sessionStateChangeNotifierInitialized = true;
      } else if (this._sessionChecker) {
        this._sessionChecker.enable();
      }
    }
  }, {
    key: "_initAutoLogoutSupport",
    value: function _initAutoLogoutSupport() {
      var _this2 = this;
      // auto-logout when server-side session reaches its expiration time (or when token
      // reaches its expiration time in case that server-side session info is not available)
      // triggering registered sessionChanged listeners
      // NOTE This assumes that whenever a token changes, sessionChanged listeners are run
      // (so that info from new token gets checked again).
      var autoLogoutTimeout;
      this.addListener("sessionChanged", function (event) {
        if (autoLogoutTimeout) {
          clearTimeout(autoLogoutTimeout);
          autoLogoutTimeout = null;
        }
        if (!_this2._currentSession || !_this2._currentSession.isAuthenticated()) return;

        // plan local logout
        var expiresAt = _this2._currentSession.getExpiresAt() || 1000 * (_this2._currentSession.getAttribute("exp") || 0);
        if (!expiresAt) return;
        var now = Date.now();
        var delay = Math.max(0, expiresAt - now);
        _this2._logger.debug("Planning local auto-logout at ".concat(_this2._toTimeString(new Date(now + delay)), "."));
        autoLogoutTimeout = setTimeout(function () {
          autoLogoutTimeout = null;
          _this2._localLogout();
        }, delay);
      });
    }
  }, {
    key: "_initAutoTokenRefresh",
    value: function _initAutoTokenRefresh() {
      var _this3 = this;
      // support for session auto-refresh when its nearing expiration or when tab is activated
      // NOTE This assumes that whenever a token changes, sessionChanged listeners are run
      // (so that token refreshing gets re-planned / cleaned).
      var tokenRefreshEnabled = Config.getBoolean(CONFIG_PREFIX + this._serviceName + "_token_refresh_enabled");
      if (tokenRefreshEnabled == null) tokenRefreshEnabled = true;
      var tokenRefreshLeeway = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_token_refresh_leeway");
      if (tokenRefreshLeeway == null) tokenRefreshLeeway = 5 * 60;
      var tokenRefreshFailureRetryInterval = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_token_refresh_failure_retry_interval");
      if (tokenRefreshFailureRetryInterval == null || tokenRefreshFailureRetryInterval < 0) tokenRefreshFailureRetryInterval = 30;
      if (tokenRefreshFailureRetryInterval) tokenRefreshFailureRetryInterval = Math.max(5, tokenRefreshFailureRetryInterval);
      var tokenRefreshFailureRetryCount = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_token_refresh_failure_retry_count");
      if (tokenRefreshFailureRetryCount == null || tokenRefreshFailureRetryCount < 0) tokenRefreshFailureRetryCount = 3;
      this._tokenRefreshInProgressCount = 0;
      this._tokenRefreshFailureRetryInterval = tokenRefreshFailureRetryInterval;
      this._tokenRefreshFailureRetryCount = tokenRefreshFailureRetryCount;
      this._tokenRefreshFailureRetryTimer = null;
      var sessionRefreshTimeout;
      this.addListener("sessionChanged", function (e) {
        if (!tokenRefreshEnabled) return;
        if (sessionRefreshTimeout) {
          clearTimeout(sessionRefreshTimeout);
          sessionRefreshTimeout = null;
        }
        var expiresAt = _this3._currentSession && _this3._currentSession.isAuthenticated() && _this3._currentSession.getAttribute("exp") * 1000;
        if (!expiresAt) return;

        // plan token refresh
        var delay;
        var now = Date.now();
        var validity = expiresAt - now;
        if (validity <= 0) {
          _this3._logger.warn("Received already expired token due to expired session - ending with local logout.");
          _this3._localLogout();
          return;
        } else if (validity < tokenRefreshLeeway * 1000) {
          _this3._logger.warn("Received token with unexpectedly short expiration time of ".concat(Math.floor(validity / 1000), "s. Either session is ") + "nearing expiration, or current configuration of automatic token refresh is not suitable for used oidc provider.");
          delay = validity - Math.floor(validity / 10); // refresh when expiration time is at 90%
        } else {
          delay = validity - tokenRefreshLeeway * 1000;
        }
        delay = Math.max(delay, 1000); // wait at least 1s between 2 token refreshes
        _this3._logger.debug("Planning token auto-refresh at ".concat(_this3._toTimeString(new Date(now + delay)), "."));
        sessionRefreshTimeout = setTimeout(function () {
          sessionRefreshTimeout = null;
          _this3._silentTokenRefresh();
        }, delay);
      });
      if (tokenRefreshEnabled) {
        window.addEventListener("focus", function () {
          return _this3.checkSession(true);
        });
        document.addEventListener("visibilitychange", function () {
          return document.visibilityState === "visible" && _this3.checkSession(true);
        });
      }
    }
  }, {
    key: "_initSessionExtendedAndExpiringSupport",
    value: function _initSessionExtendedAndExpiringSupport() {
      var _this4 = this;
      // support for "session extended" notification
      // NOTE This assumes that whenever a token changes, sessionChanged listeners are run.
      var sessionExtendByClientCertFailureRetryInterval = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_extend_by_client_cert_failure_retry_interval");
      if (sessionExtendByClientCertFailureRetryInterval == null || sessionExtendByClientCertFailureRetryInterval < 0) sessionExtendByClientCertFailureRetryInterval = 30;
      if (sessionExtendByClientCertFailureRetryInterval) sessionExtendByClientCertFailureRetryInterval = Math.max(5, sessionExtendByClientCertFailureRetryInterval);
      var sessionExtendByClientCertFailureRetryCount = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_extend_by_client_cert_failure_retry_count");
      if (sessionExtendByClientCertFailureRetryCount == null || sessionExtendByClientCertFailureRetryCount < 0) sessionExtendByClientCertFailureRetryCount = 3;
      this._sessionExtendByClientCertFailureRetryInterval = sessionExtendByClientCertFailureRetryInterval;
      this._sessionExtendByClientCertFailureRetryCount = sessionExtendByClientCertFailureRetryCount;
      var LEEWAY_MILLIS = 10 * 1000;
      var activeSessionExpiresAtMillis;
      this.addListener("sessionChanged", function (e) {
        var globalSessionExpiresAt = _this4._currentSession.getExpiresAt() || 0;
        var wasExtended = activeSessionExpiresAtMillis && globalSessionExpiresAt > activeSessionExpiresAtMillis + LEEWAY_MILLIS;
        activeSessionExpiresAtMillis = globalSessionExpiresAt;
        if (wasExtended) {
          _this4._globalSessionExpiring = false;
          var expiresAt = activeSessionExpiresAtMillis;
          // we're currently processing "sessionChanged" listeners so let them finish and run "sessionExtended" afterwards
          setTimeout(function () {
            _this4._triggerEvent("sessionExtended", {
              expiresAt: expiresAt
            });
          }, 0);
        }
      });

      // support for "session expiring" notification
      // NOTE Must be after "session extended" functionality (so that unblocking done there
      // gets performed sooner than the code below).
      // NOTE This assumes that whenever a token changes, sessionChanged listeners are run.
      var sessionExpiringNotificationTime = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_expiring_notification_time");
      if (sessionExpiringNotificationTime == null) sessionExpiringNotificationTime = 30 * 60;
      var prevUuIdentity = undefined;
      var sessionExpiringTimeout;
      this.addListener("sessionChanged", function (e) {
        if (sessionExpiringNotificationTime <= 0) return; // disabled

        if (sessionExpiringTimeout) {
          clearTimeout(sessionExpiringTimeout);
          sessionExpiringTimeout = null;
        }
        var newIdentity = _this4._currentSession && _this4._currentSession.isAuthenticated() && _this4._currentSession.getIdentity();
        var newUuIdentity = newIdentity && newIdentity.getUuIdentity();
        if (newUuIdentity != prevUuIdentity) _this4._globalSessionExpiring = false;
        prevUuIdentity = newUuIdentity;
        var expiresAt = _this4._currentSession.getExpiresAt();
        if (!expiresAt) return; // not logged in || "session expiring" notification not supported on server
        if (_this4._globalSessionExpiring) return; // don't trigger "session expiring" multiple times for the same session

        var now = Date.now();
        var delay = Math.max(0, expiresAt - now - sessionExpiringNotificationTime * 1000);
        _this4._logger.debug("Planning sessionExpiring notification at ".concat(_this4._toTimeString(new Date(now + delay)), "."));
        sessionExpiringTimeout = setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                sessionExpiringTimeout = null;
                // try to silently Session extend - if sucessfull then no need to trigger sessionExpiring event
                _context14.next = 3;
                return _this4._trySilentSessionExtendByClientCert();
              case 3:
                if (!_context14.sent) {
                  _context14.next = 5;
                  break;
                }
                return _context14.abrupt("return");
              case 5:
                _this4._globalSessionExpiring = true;
                _this4._triggerEvent("sessionExpiring", {
                  expiresAt: expiresAt
                });
              case 7:
              case "end":
                return _context14.stop();
            }
          }, _callee14);
        })), delay);
      });
      this.addListener("sessionExpiring", function (e) {
        var expiresAt = e.data.expiresAt;
        var delay = Math.floor((expiresAt - Date.now()) / 2);
        if (delay > 5000) {
          // below 5 seconds, it is probably impossible to finish re-authentication (session is practically expired)
          if (sessionExpiringTimeout) {
            clearTimeout(sessionExpiringTimeout);
          }
          sessionExpiringTimeout = setTimeout(function () {
            sessionExpiringTimeout = null;
            _this4._globalSessionExpiring = true;
            _this4._triggerEvent("sessionExpiring", {
              expiresAt: expiresAt
            });
          }, delay);
        }
      });
    }
  }, {
    key: "_initSessionStateChangeNotifier",
    value: function () {
      var _initSessionStateChangeNotifier2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        var _this5 = this;
        var sessionCheckInterval, clientId;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              // add session state checking which, in case that we were logged in and a logout
              // against OIDC is detected (e.g. in another browser tab), will log us out
              sessionCheckInterval = Config.getNumber(CONFIG_PREFIX + this._serviceName + "_session_check_interval");
              if (sessionCheckInterval == null) sessionCheckInterval = 5;
              _context15.t0 = sessionCheckInterval;
              if (!_context15.t0) {
                _context15.next = 7;
                break;
              }
              _context15.next = 6;
              return this._authnFlow.isCheckSessionSupported();
            case 6:
              _context15.t0 = _context15.sent;
            case 7:
              if (!_context15.t0) {
                _context15.next = 14;
                break;
              }
              _context15.next = 10;
              return ClientCredentialsProvider.getClientId(this._serviceName);
            case 10:
              clientId = _context15.sent;
              this._sessionChecker = new SessionStateChangeNotifier(this._authnFlow, sessionCheckInterval, clientId, function () {
                return _this5._currentSession.getState();
              });
              this._sessionChecker.onStateChange(function () {
                _this5._logger.info("Session state change detected.");
                // check login state against OpenID server (basically renew the token,
                // possibly logging out if the current user on OpenID server differs from ours)
                _this5._silentTokenRefresh(true);
              });
              this._sessionChecker.onStateUnknown(function () {
                _this5._logger.info("Unexpected session loss detected.");
                _this5._triggerEvent("sessionLost");
              });
            case 14:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function _initSessionStateChangeNotifier() {
        return _initSessionStateChangeNotifier2.apply(this, arguments);
      }
      return _initSessionStateChangeNotifier;
    }()
  }, {
    key: "_triggerEvent",
    value: function _triggerEvent(eventType, data) {
      var _this6 = this;
      this._logger.debug("Launching event \"".concat(eventType, "\"."));
      var list = this._listeners[eventType];
      if (list) {
        var e = {
          type: eventType,
          data: data
        };
        list.forEach(function (it) {
          return it.call(_this6, e);
        });
      }
    }
  }, {
    key: "_onSessionClose",
    value: function _onSessionClose(session) {
      this._localLogout();
    }
  }, {
    key: "_localLogout",
    value: function _localLogout() {
      this._logger.debug("Performing local-logout.");
      this._currentSession.removeFromCache();
      if (this._currentSession != this._emptySession) {
        this._currentSession = this._emptySession;
        this._globalSessionExpiring = false;
        this._triggerEvent("sessionChanged", this._currentSession);
      }
      if (this._sessionChecker) {
        this._sessionChecker.disable();
      }
      if (this._tokenRefreshFailureRetryTimer) {
        clearTimeout(this._tokenRefreshFailureRetryTimer);
        this._tokenRefreshFailureRetryTimer = null;
      }
    }

    /**
     * Tries to re-authenticate the user silently:
     * - if we are locally logged out => do nothing
     * - if a user is logged in (on remote) and it's the same user as ours => use the new token
     * - if a user is logged in (on remote) and it's not the same user as ours => perform local logout
     * - if a user is not logged in (on remote) => perform local logout
     */
  }, {
    key: "_silentTokenRefresh",
    value: function () {
      var _silentTokenRefresh2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var _this7 = this;
        var skipIfPlanned,
          retryCount,
          doSilentRenew,
          _args17 = arguments;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              skipIfPlanned = _args17.length > 0 && _args17[0] !== undefined ? _args17[0] : false;
              if (!(skipIfPlanned && (this._tokenRefreshFailureRetryTimer || this._tokenRefreshInProgressCount > 0))) {
                _context17.next = 3;
                break;
              }
              return _context17.abrupt("return");
            case 3:
              if (this._tokenRefreshFailureRetryTimer) {
                clearTimeout(this._tokenRefreshFailureRetryTimer);
                this._tokenRefreshFailureRetryTimer = null;
              }
              retryCount = 0;
              doSilentRenew = /*#__PURE__*/function () {
                var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
                  return _regeneratorRuntime().wrap(function _callee16$(_context16) {
                    while (1) switch (_context16.prev = _context16.next) {
                      case 0:
                        if (!(!_this7._currentSession || !_this7._currentSession.isAuthenticated())) {
                          _context16.next = 2;
                          break;
                        }
                        return _context16.abrupt("return");
                      case 2:
                        _this7._logger.debug("Silent token refresh - starting.");
                        ++_this7._tokenRefreshInProgressCount;
                        _context16.prev = 4;
                        _context16.next = 7;
                        return _this7._doAuthenticateRefresh();
                      case 7:
                        --_this7._tokenRefreshInProgressCount;
                        _context16.next = 14;
                        break;
                      case 10:
                        _context16.prev = 10;
                        _context16.t0 = _context16["catch"](4);
                        --_this7._tokenRefreshInProgressCount;
                        if (_this7._tokenRefreshFailureRetryTimer) {
                          _this7._logger.debug("Silent token refresh - ending current run with no-op (operation ended with unexpected error and another retry is already planned).", _context16.t0);
                        } else if (_this7._tokenRefreshFailureRetryCount && retryCount < _this7._tokenRefreshFailureRetryCount) {
                          _this7._logger.debug("Silent token refresh - ended with unexpected error, will retry in ".concat(_this7._tokenRefreshFailureRetryInterval, "s."), _context16.t0);
                          _this7._tokenRefreshFailureRetryTimer = setTimeout(function () {
                            ++retryCount;
                            _this7._tokenRefreshFailureRetryTimer = null;
                            doSilentRenew();
                          }, _this7._tokenRefreshFailureRetryInterval * 1000);
                        } else {
                          _this7._logger.debug("Silent token refresh - ended with unexpected error (and no more retries are allowed). Logging out.", _context16.t0);
                          _this7._localLogout();
                        }
                      case 14:
                      case "end":
                        return _context16.stop();
                    }
                  }, _callee16, null, [[4, 10]]);
                }));
                return function doSilentRenew() {
                  return _ref7.apply(this, arguments);
                };
              }();
              _context17.next = 8;
              return doSilentRenew();
            case 8:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function _silentTokenRefresh() {
        return _silentTokenRefresh2.apply(this, arguments);
      }
      return _silentTokenRefresh;
    }()
  }, {
    key: "_trySilentSessionExtendByClientCert",
    value: function () {
      var _trySilentSessionExtendByClientCert2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        var _this8 = this;
        var retryCount, doSilentExtend;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              if (Config.getBoolean(CONFIG_PREFIX + this._serviceName + "_mtls_enabled", false)) {
                _context19.next = 2;
                break;
              }
              return _context19.abrupt("return");
            case 2:
              retryCount = 0;
              doSilentExtend = /*#__PURE__*/function () {
                var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
                  var authTime, now, maxAge;
                  return _regeneratorRuntime().wrap(function _callee18$(_context18) {
                    while (1) switch (_context18.prev = _context18.next) {
                      case 0:
                        _this8._logger.debug("Silent Session extend by Client Certificate - starting.");
                        _context18.prev = 1;
                        authTime = _this8._currentSession.getAuthenticationTime().getTime() / 1000;
                        now = Date.now() / 1000; // maxAge calculated as maximum possible value - 5s tolerance
                        maxAge = Math.round(now - authTime - 5);
                        _context18.next = 7;
                        return _this8.authenticate({
                          prompt: "none",
                          maxAge: maxAge
                        });
                      case 7:
                        _this8._logger.debug("Silent Session extend by Client Certificate - Session was extended");
                        return _context18.abrupt("return", true);
                      case 11:
                        _context18.prev = 11;
                        _context18.t0 = _context18["catch"](1);
                        if (!(_this8._sessionExtendByClientCertFailureRetryCount && retryCount < _this8._sessionExtendByClientCertFailureRetryCount)) {
                          _context18.next = 21;
                          break;
                        }
                        _this8._logger.debug("Silent Session extend by Client Certificate - ended with unexpected error, will retry in ".concat(_this8._sessionExtendByClientCertFailureRetryInterval, "s."), _context18.t0);
                        _context18.next = 17;
                        return _this8._waitFor(_this8._sessionExtendByClientCertFailureRetryInterval * 1000);
                      case 17:
                        ++retryCount;
                        return _context18.abrupt("return", doSilentExtend());
                      case 21:
                        _this8._logger.debug("Silent Session extend by Client Certificate - ended with unexpected error (and no more retries are allowed).", _context18.t0);
                        return _context18.abrupt("return", false);
                      case 23:
                      case "end":
                        return _context18.stop();
                    }
                  }, _callee18, null, [[1, 11]]);
                }));
                return function doSilentExtend() {
                  return _ref8.apply(this, arguments);
                };
              }();
              _context19.next = 6;
              return doSilentExtend();
            case 6:
              return _context19.abrupt("return", _context19.sent);
            case 7:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function _trySilentSessionExtendByClientCert() {
        return _trySilentSessionExtendByClientCert2.apply(this, arguments);
      }
      return _trySilentSessionExtendByClientCert;
    }()
  }, {
    key: "_waitFor",
    value: function _waitFor(millSeconds) {
      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve();
        }, millSeconds);
      });
    }
  }, {
    key: "_equalsArray",
    value: function _equalsArray(array1, array2) {
      return array1.length === array2.length && array1.every(function (it, i) {
        return it === array2[i];
      });
    }
  }, {
    key: "_toTimeString",
    value: function _toTimeString(date) {
      return (
        // date.getFullYear() + "-" + ("0" + (date.getMonth() + 1)).substr(-2) + "-" + ("0" + date.getDate()).substr(-2) + " " +
        ("0" + date.getHours()).substr(-2) + ":" + ("0" + date.getMinutes()).substr(-2) + ":" + ("0" + date.getSeconds()).substr(-2)
      );
    }
  }, {
    key: "_doAuthenticateRefresh",
    value: function () {
      var _doAuthenticateRefresh2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        var authConstraints, scope, acrValues, maxAge, result, supportedAcrValues, session, curSessIdentity, newSessIdentity, authCtx;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.prev = 0;
              if (this._oauthClient) {
                _context20.next = 4;
                break;
              }
              _context20.next = 4;
              return this._loadOauthClientPromise;
            case 4:
              if (this._authnFlow) {
                _context20.next = 7;
                break;
              }
              _context20.next = 7;
              return this._loadAuthnFlowPromise;
            case 7:
              authConstraints = this._currentSession ? this._currentSession._authConstraints : null;
              scope = authConstraints ? authConstraints.scope : null;
              acrValues = authConstraints ? authConstraints.acrValues : null;
              maxAge = authConstraints ? authConstraints.maxAge : null;
              if (!this._authnFlow.refreshSession) {
                _context20.next = 17;
                break;
              }
              _context20.next = 14;
              return this._authnFlow.refreshSession({
                acrValues: acrValues,
                maxAge: maxAge
              }, scope);
            case 14:
              result = _context20.sent;
              _context20.next = 20;
              break;
            case 17:
              _context20.next = 19;
              return this._authnFlow.authenticate({
                acrValues: acrValues,
                maxAge: maxAge,
                prompt: "none",
                usePopup: false
              }, scope);
            case 19:
              result = _context20.sent;
            case 20:
              if (!(!this._currentSession || !this._currentSession.isAuthenticated())) {
                _context20.next = 24;
                break;
              }
              // no-op (we've become logged out and don't want to silently auto-login)
              this._logger.debug("Silent token refresh - ending with no-op (local session is already logged out).");
              _context20.next = 35;
              break;
            case 24:
              if (!(this._currentSession && this._currentSession._supportedAcrValues)) {
                _context20.next = 28;
                break;
              }
              supportedAcrValues = this._currentSession._supportedAcrValues;
              _context20.next = 31;
              break;
            case 28:
              _context20.next = 30;
              return this._oauthClient.getSupportedAcrValues();
            case 30:
              supportedAcrValues = _context20.sent;
            case 31:
              session = new Session(this._serviceName, this._oauthClient, supportedAcrValues, result.claims, result.idToken, result.accessToken); // if the user is different than the current one then perform logout
              curSessIdentity = this._currentSession.getIdentity();
              newSessIdentity = session.getIdentity();
              if (curSessIdentity && newSessIdentity && curSessIdentity.getUuIdentity() !== newSessIdentity.getUuIdentity() || (!curSessIdentity || !newSessIdentity) && curSessIdentity != newSessIdentity) {
                this._logger.debug("Silent token refresh - ending with local logout (user that is logged in on remote is different from the local one).");
                this._localLogout();
              } else {
                // everything is fine - use new session
                this._logger.debug("Silent token refresh - ending with token renewed.");
                authCtx = this._currentSession.getAuthenticationContext();
                session = BrowserSession.from(session, authCtx, result.globalSessionExpiresAt, result.globalSessionState, this);
                session._authConstraints = authConstraints;
                this._currentSession = session;
                if (session) {
                  session._onCloseListener = this._onSessionClose.bind(this);
                  session.storeToCache(result.clientId);
                }
                this._triggerEvent("sessionChanged", session);
              }
            case 35:
              _context20.next = 46;
              break;
            case 37:
              _context20.prev = 37;
              _context20.t0 = _context20["catch"](0);
              if (!(_context20.t0 instanceof InteractionRequired)) {
                _context20.next = 44;
                break;
              }
              this._logger.debug("Silent token refresh ending with local logout, user interaction is required (".concat(_context20.t0.code, ")."));
              this._localLogout();
              _context20.next = 46;
              break;
            case 44:
              this._logger.error("Silent token refresh failed.", _context20.t0);
              throw _context20.t0;
            case 46:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this, [[0, 37]]);
      }));
      function _doAuthenticateRefresh() {
        return _doAuthenticateRefresh2.apply(this, arguments);
      }
      return _doAuthenticateRefresh;
    }()
  }], [{
    key: "_onPageLoad",
    value:
    /**
     * Internal function invoked once page is loaded.
     * @return {Promise<void>}
     * @private
     */
    function () {
      var _onPageLoad2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(callToken) {
        var onPageLoadInternal;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              if (!this._onPageLoadPromise) {
                this._onPageLoadFinished = false;
                onPageLoadInternal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
                  var restoreOnLoad, primaryProvider;
                  return _regeneratorRuntime().wrap(function _callee21$(_context21) {
                    while (1) switch (_context21.prev = _context21.next) {
                      case 0:
                        restoreOnLoad = AbstractAuthorizationFlow.getRestoreSessionOnLoad();
                        if (!(restoreOnLoad !== RESTORE_SESSION_DISABLED)) {
                          _context21.next = 6;
                          break;
                        }
                        _context21.next = 4;
                        return this.restoreSession({
                          callToken: callToken
                        });
                      case 4:
                        _context21.next = 10;
                        break;
                      case 6:
                        // In case restore of session is not enabled, we have to do some
                        // initialization anyway in order to interactive authentication to
                        // work (Browsers are limiting maximum number of awaits when
                        // displaying popup, therefore these data must be loaded beforehand).
                        primaryProvider = this._providers[this._primaryProvider];
                        if (!primaryProvider) {
                          _context21.next = 10;
                          break;
                        }
                        _context21.next = 10;
                        return primaryProvider._loadAsyncData();
                      case 10:
                        this._onPageLoadFinished = true;
                      case 11:
                      case "end":
                        return _context21.stop();
                    }
                  }, _callee21, this);
                })).bind(this);
                this._onPageLoadPromise = onPageLoadInternal();
              }
              return _context22.abrupt("return", this._onPageLoadPromise);
            case 2:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function _onPageLoad(_x8) {
        return _onPageLoad2.apply(this, arguments);
      }
      return _onPageLoad;
    }()
    /**
     * Load and initialize authentication service(s)
     * @private
     */
  }, {
    key: "load",
    value: function load() {
      var reconfigure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      DefaultServiceLoader.load(AuthenticationService, reconfigure);
    }

    /**
     * Creates new instance of uuOIDC authentication service and registers it
     * as authentication service with given name.
     * @param {String} name Service name
     * @param {Object|null} opts Service options
     * @param {String|Uri|null} opts.serviceUri Base URI of OIDC server
     * @param {number} options.tokenCacheSize Maximal size of call token cache
     * @param {number} options.tokenTimeLeeway Time verification tolerance (in seconds)
     */
  }, {
    key: "create",
    value: function create(name) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Do not allow reinitialization of already registered services
      var force = opts.force || false;
      if (!force && this._providers[name]) {
        return;
      }
      var authService = new this(name, opts);
      // Register service in global authentication service component
      CoreAuthenticationService._register(name, authService);
      // Register oidc meta-service to be able to use multiple oidc providers via generic API
      CoreAuthenticationService._register(META_SERVICE_NAME, this);
      // Store service localy
      // (to be able to choose service based on tokens)
      this._providers[name] = authService;
      if (!this._primaryProvider) {
        this._primaryProvider = name;
      }
      this._restoreSessionPromise = null;
      this._isRestoringSession = false;
      this._logger = LoggerFactory.get("uuapp.oidc.AuthenticationService");
    }

    /**
     * Authenticates user (using primary authentication service).
     * @param {Object|null} options Options
     * @param {String} options.acrValues Requested authentication level
     * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
     * @param {String} options.prompt One of null (show login page if not authenticated), "login" (show login page regardless of authentication state), "none" (silently find out authentication state).
     * @param {String} options.language What language the login page should use.
     * @param {String} options.os8Token Authenticates the user using uuOS8 token.
     * @param {Boolean} options.usePopup Flag if login form should be displayed in popup (default) or in main application window.
     * @param {String} options.scopeMode Scope mode (one of [useCase, allUseCases, baseUri, none]). Applied only if scope is not explicitly set.
     * @param {String} scope Scope allows for limitations of where resulting session can be used (defaults to application baseUri unless scope mode is set to "none").
     * @returns {Promise<Session>} User session for authenticated user.
     */
  }, {
    key: "authenticate",
    value: function () {
      var _authenticate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(options) {
        var scope,
          primaryProvider,
          _args23 = arguments;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              scope = _args23.length > 1 && _args23[1] !== undefined ? _args23[1] : null;
              if (!this._onPageLoadPromise) {
                // Workaround for IE 11 (due to unreliable promises, authenticate
                // method can be invoked before onPageLoad is called)
                this._onPageLoad(null);
              }
              if (this._onPageLoadFinished) {
                _context23.next = 5;
                break;
              }
              _context23.next = 5;
              return this._onPageLoadPromise;
            case 5:
              primaryProvider = this._providers[this._primaryProvider];
              _context23.next = 8;
              return primaryProvider.authenticate(options, scope);
            case 8:
              return _context23.abrupt("return", _context23.sent);
            case 9:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function authenticate(_x9) {
        return _authenticate2.apply(this, arguments);
      }
      return authenticate;
    }()
    /**
     * Returns whether an authentication of primary authentication service is in progress.
     * @returns {boolean} Whether an authentication of primary authentication service is in progress.
     */
  }, {
    key: "isAuthenticating",
    value: function isAuthenticating() {
      var primaryProvider = this._providers[this._primaryProvider];
      return primaryProvider ? primaryProvider.isAuthenticating() : null;
    }

    /**
     * Returns name of primary authentication service.
     * @returns {String} Name of primary authentication service
     */
  }, {
    key: "getServiceName",
    value: function getServiceName() {
      var primaryProvider = this._providers[this._primaryProvider];
      return primaryProvider ? primaryProvider.getServiceName() : null;
    }

    /**
     * Returns URI of primary authentication service.
     * @returns {String} URI of primary authentication service
     */
  }, {
    key: "getServiceUri",
    value: function () {
      var _getServiceUri2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
        var primaryProvider;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              primaryProvider = this._providers[this._primaryProvider];
              if (!primaryProvider) {
                _context24.next = 7;
                break;
              }
              _context24.next = 4;
              return primaryProvider.getServiceUri();
            case 4:
              _context24.t0 = _context24.sent;
              _context24.next = 8;
              break;
            case 7:
              _context24.t0 = null;
            case 8:
              return _context24.abrupt("return", _context24.t0);
            case 9:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function getServiceUri() {
        return _getServiceUri2.apply(this, arguments);
      }
      return getServiceUri;
    }()
    /**
     * Returns URI of primary authentication service.
     * @returns {String} URI of primary authentication service
     * @deprecated
     */
  }, {
    key: "getProviderUri",
    value: function getProviderUri() {
      var primaryProvider = this._providers[this._primaryProvider];
      return primaryProvider ? primaryProvider.getProviderUri() : null;
    }

    /**
     * Returns current session of primary authentication service or null if the user is not logged in.
     * @returns {Session} Current session of primary authentication service or null if the user is not logged in.
     */
  }, {
    key: "getCurrentSession",
    value: function getCurrentSession() {
      var primaryProvider = this._providers[this._primaryProvider];
      return primaryProvider ? primaryProvider.getCurrentSession() : null;
    }

    /**
     * Restores session of primary authentication service.
     * @param {Object|null} options Options
     * @param {String} options.acrValues Requested authentication level
     * @param {String} options.maxAge Requested maximum age (in seconds) of user authentication
     * @returns {Promise<Session>} Promise resolved when session restoration ends.
     */
  }, {
    key: "restoreSession",
    value: function () {
      var _restoreSession4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
        var options,
          authReferrer,
          restoreSessionInternal,
          _args26 = arguments;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              options = _args26.length > 0 && _args26[0] !== undefined ? _args26[0] : {};
              // If redirection was used for session restore, provide original referrer
              authReferrer = sessionStorage.getItem("uu_app_oidc_auth_referrer");
              sessionStorage.removeItem("uu_app_oidc_auth_referrer");
              document.originalReferrer = authReferrer || "";
              if (!this._restoreSessionPromise) {
                this._isRestoringSession = true;
                restoreSessionInternal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
                  var secondaryProvidersEnabled, sortedProviders, _i, _Object$values, provider, authenticationErrors, session, origPrimaryProvider, _i2, _sortedProviders, _provider, _iterator, _step, _step$value, serviceName, error;
                  return _regeneratorRuntime().wrap(function _callee25$(_context25) {
                    while (1) switch (_context25.prev = _context25.next) {
                      case 0:
                        secondaryProvidersEnabled = Config.getBoolean(SECONDARY_PROVIDERS_ENABLED_CFG);
                        if (secondaryProvidersEnabled == null) {
                          secondaryProvidersEnabled = false;
                        }
                        if (!(!secondaryProvidersEnabled || Object.keys(this._providers).length === 1)) {
                          _context25.next = 12;
                          break;
                        }
                        _context25.prev = 3;
                        _context25.next = 6;
                        return this._providers[this._primaryProvider].restoreSession(options);
                      case 6:
                        return _context25.abrupt("return", _context25.sent);
                      case 7:
                        _context25.prev = 7;
                        this._isRestoringSession = false;
                        return _context25.finish(7);
                      case 10:
                        _context25.next = 54;
                        break;
                      case 12:
                        this._logger.debug("Trying to restore session for any available authentication service.");
                        sortedProviders = [];
                        sortedProviders.push(this._providers[this._primaryProvider]);
                        for (_i = 0, _Object$values = Object.values(this._providers); _i < _Object$values.length; _i++) {
                          provider = _Object$values[_i];
                          if (provider.getServiceName() !== this._primaryProvider) {
                            sortedProviders.push(provider);
                          }
                        }
                        authenticationErrors = [];
                        session = null;
                        origPrimaryProvider = this._primaryProvider;
                        _i2 = 0, _sortedProviders = sortedProviders;
                      case 20:
                        if (!(_i2 < _sortedProviders.length)) {
                          _context25.next = 39;
                          break;
                        }
                        _provider = _sortedProviders[_i2];
                        this._primaryProvider = _provider.getServiceName();
                        _context25.prev = 23;
                        _context25.next = 26;
                        return _provider.restoreSession(options);
                      case 26:
                        session = _context25.sent;
                        if (!(session.getIdentity() && session.getIdentity().getUuIdentity())) {
                          _context25.next = 30;
                          break;
                        }
                        this._logger.debug("Setting ".concat(_provider.getServiceName(), " as default service."));
                        return _context25.abrupt("break", 39);
                      case 30:
                        _context25.next = 35;
                        break;
                      case 32:
                        _context25.prev = 32;
                        _context25.t0 = _context25["catch"](23);
                        authenticationErrors.push([_provider.getServiceName(), _context25.t0]);
                      case 35:
                        this._primaryProvider = origPrimaryProvider;
                      case 36:
                        _i2++;
                        _context25.next = 20;
                        break;
                      case 39:
                        if (session.getIdentity()) {
                          _context25.next = 52;
                          break;
                        }
                        this._logger.debug("No existing session found, keeping ".concat(this._primaryProvider, " as default service."));
                        if (!(authenticationErrors.length > 0)) {
                          _context25.next = 48;
                          break;
                        }
                        // Log authentication errors
                        _iterator = _createForOfIteratorHelper(authenticationErrors);
                        try {
                          for (_iterator.s(); !(_step = _iterator.n()).done;) {
                            _step$value = _slicedToArray(_step.value, 2), serviceName = _step$value[0], error = _step$value[1];
                            this._logger.error("Authentication with ".concat(serviceName, " failed."), error);
                          }
                          // "Throw" last of errors
                        } catch (err) {
                          _iterator.e(err);
                        } finally {
                          _iterator.f();
                        }
                        this._isRestoringSession = false;
                        throw authenticationErrors.pop()[1];
                      case 48:
                        this._isRestoringSession = false;
                        return _context25.abrupt("return", session);
                      case 50:
                        _context25.next = 54;
                        break;
                      case 52:
                        this._isRestoringSession = false;
                        return _context25.abrupt("return", session);
                      case 54:
                      case "end":
                        return _context25.stop();
                    }
                  }, _callee25, this, [[3,, 7, 10], [23, 32]]);
                })).bind(this);
                this._restoreSessionPromise = restoreSessionInternal();
              }
              return _context26.abrupt("return", this._restoreSessionPromise);
            case 6:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function restoreSession() {
        return _restoreSession4.apply(this, arguments);
      }
      return restoreSession;
    }()
    /**
     * Returns whether the session of primary authentication service is in process of being restored.
     * @returns {boolean} Whether the session of primary authentication service is in process of being restored.
     */
  }, {
    key: "isRestoringSession",
    value: function isRestoringSession() {
      return this._isRestoringSession;
    }

    /**
     * Adds listener for specified event on primary authentication service.
     * Listener is a function accepting an event object, which contains following fields:
     *
     * * **type** The type of the event, e.g. "sessionChanged".
     * * **data** The data passed to the event.
     * @param {string} eventType The event to register listener for.
     * @param {function(Event)} listenerFn The function to be called whenever the event is trigerred.
     * @return {Function()} Function for unregistering the listener (the listener can be unregistered also by {@link #removeListener}).
     */
  }, {
    key: "addListener",
    value: function addListener(eventType, listenerFn) {
      var removeFnList = [];
      for (var _i3 = 0, _Object$values2 = Object.values(this._providers); _i3 < _Object$values2.length; _i3++) {
        var provider = _Object$values2[_i3];
        removeFnList.push(provider.addListener(eventType, listenerFn));
      }
      return function () {
        for (var _i4 = 0, _removeFnList = removeFnList; _i4 < _removeFnList.length; _i4++) {
          var removeFn = _removeFnList[_i4];
          removeFn();
        }
      };
    }

    /**
     * Removes listener for specified event on primary authentication service.
     * @param {string} eventType The event to remove listener for.
     * @param {function(Event)} listenerFn The listener (function) to unregister.
     * @return {boolean} True if the listener got removed, false otherwise (listener was not registered).
     */
  }, {
    key: "removeListener",
    value: function removeListener(eventType, listenerFn) {
      for (var _i5 = 0, _Object$values3 = Object.values(this._providers); _i5 < _Object$values3.length; _i5++) {
        var provider = _Object$values3[_i5];
        provider.removeListener(eventType, listenerFn);
      }
    }

    /**
     * Returns whether the user (global) session of primary authentication service is expiring.
     * @returns {boolean} Whether the user (global) session of primary authentication service is expiring.
     */
  }, {
    key: "isSessionExpiring",
    value: function isSessionExpiring() {
      var primaryProvider = this._providers[this._primaryProvider];
      return primaryProvider ? primaryProvider.isSessionExpiring() : null;
    }
  }]);
  return AuthenticationService;
}();
AuthenticationService._providers = {};
AuthenticationService._primaryProvider = null;

// Load all available OIDC authentication services
AuthenticationService.load(false);
module.exports = AuthenticationService;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6).Authentication;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__6__;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6).Util;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6).Logging;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6).AppClient;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(7),
  Config = _require.Config,
  BaseError = _require.BaseError;
var _require2 = __webpack_require__(5),
  AuthenticationService = _require2.AuthenticationService;
var BASE_CONFIG_PREFIX = "uu_app_oidc_providers_";
var PRIMARY_PROVIDER_CFG = "uu_app_oidc_primary_provider";
var ALLOW_AUDIENCE_ALIAS_CFG = "uu_app_oidc_allow_audience_alias";
var DISABLE_WEBCRYPTO_API = "uu_app_oidc_disable_webcrypto_api";
var OIDCG01_SERVICE_NAME = "oidcg01";
var OIDCG01_SERVICE_ENABLED = false;
var OIDCG01_SERVICE_URI = "https://oidc.plus4u.net/uu-oidcg01-main/99923616732452117-4f06dafc03cb4c7f8c155aa53f0e86be";
var OIDCG01_VERIFY_AUDIENCE = false;
var OIDCG01_ACCESS_TOKEN_PATTERN = "^UUOIDCAT-.*";
var OIDCG01_REFRESH_TOKEN_PATTERN = "^UUOIDCRT-.*";
var OIDCG02_SERVICE_NAME = "oidcg02";
var OIDCG02_SERVICE_ENABLED = true;
var OIDCG02_SERVICE_URI = "https://uuidentity.plus4u.net/uu-oidc-maing02/bb977a99f4cc4c37a2afce3fd599d0a7/oidc";
var OIDCG02_VERIFY_AUDIENCE = true;
var OIDCG02_ACCESS_TOKEN_PATTERN = "^at.*";
var OIDCG02_REFRESH_TOKEN_PATTERN = "^rt.*";
var DefaultServiceLoader = /*#__PURE__*/function () {
  function DefaultServiceLoader() {
    _classCallCheck(this, DefaultServiceLoader);
  }
  _createClass(DefaultServiceLoader, null, [{
    key: "load",
    value: function load(serviceClass) {
      var reconfigure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (reconfigure) {
        Object.keys(serviceClass._providers).forEach(function (name) {
          delete AuthenticationService._realizations[name];
        });
        serviceClass._providers = {};
        serviceClass._primaryProvider = null;
      }
      // Declare default services (which will be also first to try)
      // Defaults to implicit configuration of uuOidcg02 and uuOidcg01
      this.loadOidcg02(serviceClass, reconfigure);
      this.loadOidcg01(serviceClass, reconfigure);
      // Register additional services based on configuration
      var configObject = null;
      if (typeof window == "undefined") {
        configObject = Config.toJSON();
      } else {
        // Workaround for IE where it is not possible to serialize UU5.Environment
        // into JSON (which is internally used for deep copy of configuration)
        // due to incompatible types (like regular expression) in configuration.
        // Since on browser the only configuration source is UUE.Environment
        // we can directly use its config source.
        var uu5EnvSource = Config.chain._sources[0];
        configObject = Object.assign(uu5EnvSource ? uu5EnvSource._data : {}, Config.chain._custom);
      }
      var keys = Object.keys(configObject);
      for (var i = 0; i < keys.length; i += 1) {
        var key = keys[i];
        var value = configObject[key];
        var matchResult = new RegExp("^".concat(BASE_CONFIG_PREFIX, "(.*)_uri$")).exec(key);
        if (!matchResult) {
          continue;
        }
        var serviceName = matchResult[1];
        var configPrefix = "".concat(BASE_CONFIG_PREFIX).concat(serviceName);
        if (serviceName === OIDCG01_SERVICE_NAME || serviceName === OIDCG02_SERVICE_NAME) {
          continue;
        }
        var enabled = Config.getBoolean("".concat(configPrefix, "_enabled"), false);
        if (typeof enabled === "boolean" && !enabled) {
          continue;
        }
        serviceName = Config.getString("".concat(configPrefix, "_name"), false) || serviceName;
        var opts = {
          serviceUri: value,
          verifySsl: Config.getBoolean("".concat(configPrefix, "_verify_ssl"), false),
          accessTokenPattern: Config.getString("".concat(configPrefix, "_access_token_pattern"), false),
          refreshTokenPattern: Config.getString("".concat(configPrefix, "_refresh_token_pattern"), false),
          verifyAudience: Config.getBoolean("".concat(configPrefix, "_verify_audience"), false),
          allowAudienceAlias: Config.getBoolean(ALLOW_AUDIENCE_ALIAS_CFG, false),
          tokenCacheSize: Config.getNumber("".concat(configPrefix, "_token_cache_size"), false),
          tokenTimeLeeway: Config.getNumber("".concat(configPrefix, "_token_time_leeway"), false),
          discoveryPath: Config.getNumber("".concat(configPrefix, "_discovery_path"), false),
          discoveryCacheTtl: Config.getNumber("".concat(configPrefix, "_discovery_cache_ttl"), false),
          jwksCacheTtl: Config.getNumber("".concat(configPrefix, "_jwks_cache_ttl"), false),
          defaultScope: Config.getString("".concat(configPrefix, "_default_scope"), false),
          perflogEnabled: Config.getBoolean("".concat(configPrefix, "_perflog_enabled"), false),
          callTokenType: Config.getString("".concat(configPrefix, "_call_token_type")),
          issuer: Config.getString("".concat(configPrefix, "_issuer")),
          oauthRealization: Config.getString("".concat(configPrefix, "_oauth_realization")),
          disableWebcryptoApi: Config.getBoolean(DISABLE_WEBCRYPTO_API, false),
          force: reconfigure
        };
        serviceClass.create(serviceName, opts);
      }
      var primaryProvider = Config.getString(PRIMARY_PROVIDER_CFG, false);
      if (primaryProvider) {
        if (!serviceClass._providers[primaryProvider]) {
          throw new BaseError("Cannot set primary provider to ".concat(primaryProvider, ". Service does not exits or is not enabled."));
        }
        serviceClass._primaryProvider = primaryProvider;
      }
    }

    /**
     * Loads uuOIDCg02
     */
  }, {
    key: "loadOidcg02",
    value: function loadOidcg02(serviceClass) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var configPrefix = "".concat(BASE_CONFIG_PREFIX).concat(OIDCG02_SERVICE_NAME);
      var enabled = Config.getBoolean("".concat(configPrefix, "_enabled"), false);
      if (typeof enabled !== "boolean") {
        enabled = OIDCG02_SERVICE_ENABLED;
      }
      if (!enabled) {
        return;
      }
      var serviceUri = Config.getString("".concat(configPrefix, "_uri"), false);
      var verifyAudience = Config.getBoolean("".concat(configPrefix, "_verify_audience"), false);
      if (verifyAudience === null || verifyAudience === undefined) {
        verifyAudience = OIDCG02_VERIFY_AUDIENCE;
      }
      var opts = {
        force: force,
        serviceUri: serviceUri || OIDCG02_SERVICE_URI,
        verifySsl: Config.getBoolean("".concat(configPrefix, "_verify_ssl"), false),
        accessTokenPattern: Config.getString("".concat(configPrefix, "_access_token_pattern"), false) || OIDCG02_ACCESS_TOKEN_PATTERN,
        refreshTokenPattern: Config.getString("".concat(configPrefix, "_refresh_token_pattern"), false) || OIDCG02_REFRESH_TOKEN_PATTERN,
        verifyAudience: verifyAudience,
        allowAudienceAlias: Config.getBoolean(ALLOW_AUDIENCE_ALIAS_CFG, false),
        tokenCacheSize: Config.getNumber("".concat(configPrefix, "_token_cache_size"), false),
        tokenTimeLeeway: Config.getNumber("".concat(configPrefix, "_token_time_leeway"), false),
        discoveryCacheTtl: Config.getNumber("".concat(configPrefix, "_discovery_cache_ttl"), false),
        jwksCacheTtl: Config.getNumber("".concat(configPrefix, "_jwks_cache_ttl"), false),
        defaultScope: Config.getString("".concat(configPrefix, "_default_scope"), false),
        perflogEnabled: Config.getBoolean("".concat(configPrefix, "_perflog_enabled"), false),
        callTokenType: Config.getString("".concat(configPrefix, "_call_token_type")),
        issuer: Config.getString("".concat(configPrefix, "_issuer")),
        oauthRealization: Config.getString("".concat(configPrefix, "_oauth_realization")),
        disableWebcryptoApi: Config.getBoolean(DISABLE_WEBCRYPTO_API, false)
      };
      serviceClass.create(OIDCG02_SERVICE_NAME, opts);
    }

    /**
     * Loads uuOIDCg01
     */
  }, {
    key: "loadOidcg01",
    value: function loadOidcg01(serviceClass) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var configPrefix = "".concat(BASE_CONFIG_PREFIX).concat(OIDCG01_SERVICE_NAME);
      var enabled = Config.getBoolean("".concat(configPrefix, "_enabled"), false);
      if (typeof enabled !== "boolean") {
        enabled = OIDCG01_SERVICE_ENABLED;
      }
      if (!enabled) {
        return;
      }
      var serviceUri = Config.getString("".concat(configPrefix, "_uri"), false);
      var verifySsl = Config.getBoolean("".concat(configPrefix, "_verify_ssl"), false);
      var verifyAudience = Config.getBoolean("".concat(configPrefix, "_verify_audience"), false);
      if (verifyAudience === null || verifyAudience === undefined) {
        verifyAudience = OIDCG01_VERIFY_AUDIENCE;
      }
      var opts = {
        force: force,
        serviceUri: serviceUri || OIDCG01_SERVICE_URI,
        verifySsl: Config.getBoolean("".concat(configPrefix, "_verify_ssl"), false),
        accessTokenPattern: Config.getString("".concat(configPrefix, "_access_token_pattern"), false) || OIDCG01_ACCESS_TOKEN_PATTERN,
        refreshTokenPattern: Config.getString("".concat(configPrefix, "_refresh_token_pattern"), false) || OIDCG01_REFRESH_TOKEN_PATTERN,
        verifyAudience: verifyAudience,
        allowAudienceAlias: Config.getBoolean(ALLOW_AUDIENCE_ALIAS_CFG, false),
        tokenCacheSize: Config.getNumber("".concat(configPrefix, "_token_cache_size"), false),
        tokenTimeLeeway: Config.getNumber("".concat(configPrefix, "_token_time_leeway"), false),
        discoveryCacheTtl: Config.getNumber("".concat(configPrefix, "_discovery_cache_ttl"), false),
        jwksCacheTtl: Config.getNumber("".concat(configPrefix, "_jwks_cache_ttl"), false),
        defaultScope: Config.getString("".concat(configPrefix, "_default_scope"), false),
        perflogEnabled: Config.getBoolean("".concat(configPrefix, "_perflog_enabled"), false),
        callTokenType: Config.getString("".concat(configPrefix, "_call_token_type")),
        issuer: Config.getString("".concat(configPrefix, "_issuer")),
        oauthRealization: Config.getString("".concat(configPrefix, "_oauth_realization")),
        disableWebcryptoApi: Config.getBoolean(DISABLE_WEBCRYPTO_API, false)
      };
      serviceClass.create(OIDCG01_SERVICE_NAME, opts);
    }
  }]);
  return DefaultServiceLoader;
}();
module.exports = DefaultServiceLoader;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(7),
  BaseError = _require.BaseError,
  LruCache = _require.LruCache,
  Base64 = _require.Base64;
var _require2 = __webpack_require__(9),
  AppClient = _require2.AppClient,
  ApplicationError = _require2.ApplicationError;
var _require3 = __webpack_require__(5),
  InvalidCredentials = _require3.InvalidCredentials,
  AuthenticationError = _require3.AuthenticationError;
var _require4 = __webpack_require__(9),
  PerflogHandler = _require4.PerflogHandler,
  RemoteErrorHandler = _require4.RemoteErrorHandler,
  TransformParametersHandler = _require4.TransformParametersHandler;
var _require5 = __webpack_require__(12),
  UriBuilder = _require5.UriBuilder;
var SyncCallNotPossible = __webpack_require__(13);
var Discovery = __webpack_require__(14);
var Jwt = __webpack_require__(15);
var LocalDomainScopeHandler = __webpack_require__(24);
var APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, TransformParametersHandler];
var APP_CLIENT_INTERCEPTORS_NO_PERFLOG = [RemoteErrorHandler, TransformParametersHandler];
var OAUTH_CLIENT_ID = "client_id";
var OAUTH_CLIENT_SECRET = "client_secret";
var MEDIA_FORM_ENCODED = "application/x-www-form-urlencoded";
var MEDIA_JSON = "application/json";
var OAUTH_CODE = "code";
var OAUTH_SCOPE = "scope";
var OAUTH_SCOPE_OPENID = "openid";
var OAUTH_GRANT_TYPE = "grant_type";
var OAUTH_GRANT_TYPE_CODE = "authorization_code";
var OAUTH_PARAM_TOKEN = "token";
var OAUTH_PARAM_TOKEN_TYPE_HINT = "token_type_hint";
var OAUTH_PARAM_REDIRECT_URI = "redirect_uri";
var OAUTH_GRANT_TYPE_RESOURCE_OWNER_PASSWORD = "password";
var OAUTH_USERNAME = "username";
var OAUTH_PASSWORD = "password";
var OAUTH_GRANT_TYPE_CLIENT_CREDENTIALS = "client_credentials";
var OAUTH_GRANT_TYPE_REFRESH_TOKEN = "refresh_token";
var OAUTH_REFRESH_TOKEN = "refresh_token";
var OAUTH_SUBJECT_TOKEN = "subject_token";
var OAUTH_SUBJECT_TOKEN_TYPE = "subject_token_type";
var OAUTH_ACTOR_TOKEN = "actor_token";
var OAUTH_ACTOR_TOKEN_TYPE = "actor_token_type";
var OAUTH_TOKEN_TYPE_ID_TOKEN = "id_token";
var OAUTH_TOKEN_TYPE_ACCESS_TOKEN = "access_token";
var OAUTH_TOKEN_TYPE_REFRESH_TOKEN = "refresh_token";
var OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN = "urn:ietf:params:oauth:token-type:".concat(OAUTH_TOKEN_TYPE_ID_TOKEN);
var OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN = "urn:ietf:params:oauth:token-type:".concat(OAUTH_TOKEN_TYPE_ACCESS_TOKEN);
var OAUTH_TOKEN_TYPE_QUALIFIED_REFRESH_TOKEN = "urn:ietf:params:oauth:token-type:".concat(OAUTH_TOKEN_TYPE_REFRESH_TOKEN);
var OAUTH_GRANT_TYPE_QUALIFIED_EXCHANGE = "urn:ietf:params:oauth:grant-type:token-exchange";
var CLIENT_PRIVATE_KEY = "client_private_key";
var CLIENT_TOKEN_TTL = 10 * 60;
var OAUTH_CLIENT_ASSERTION = "client_assertion";
var OAUTH_CLIENT_ASSERTION_TYPE = "client_assertion_type";
var OAUTH_CLIENT_ASSERTION_BEARER = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";
var DEFAULT_TOKEN_CACHE_SIZE = 2048;
var DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;
var JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;
var DEFAULT_ACCESS_TOKEN_PATTERN = ".^";
var DEFAULT_REFRESH_TOKEN_PATTERN = ".^";

// TODO Constant for workaround to allow sending of word values to G01
var G02_ACR_VALUES_OLD = ["none", "low", "medium", "high", "veryHigh"];
var G02_ACR_VALUES = ["none", "low", "standard", "high", "veryHigh"];
var OAuthClient = /*#__PURE__*/function () {
  function OAuthClient(serviceUri) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, OAuthClient);
    if (!serviceUri) {
      throw new BaseError("Service URI must be defined");
    }
    var tokenCacheSize = opts.tokenCacheSize ? Number(opts.tokenCacheSize) : DEFAULT_TOKEN_CACHE_SIZE;
    this._tokenCache = new LruCache({
      maxSize: tokenCacheSize
    });
    this._tokenTimeLeeway = opts.tokenTimeLeeway ? Number(opts.tokenTimeLeeway) : DEFAULT_TOKEN_TIME_LEEWAY;
    this._discovery = new Discovery(serviceUri, opts);
    this._jwt = new Jwt(this._discovery, opts);
    var perflogEnabled = typeof opts.perflogEnabled === "boolean" ? opts.perflogEnabled : true;
    var interceptors = perflogEnabled ? APP_CLIENT_INTERCEPTORS : APP_CLIENT_INTERCEPTORS_NO_PERFLOG;
    this._client = new AppClient(Object.assign(opts, {
      interceptors: interceptors
    }));
    this._metadata = null;
    this._serviceUri = serviceUri;
    this._customIssuer = opts.issuer;
    this._defaultScope = opts.defaultScope != null ? opts.defaultScope : OAUTH_SCOPE_OPENID;
    this._accessTokenPattern = new RegExp(opts.accessTokenPattern || DEFAULT_ACCESS_TOKEN_PATTERN);
    this._refreshTokenPattern = new RegExp(opts.refreshTokenPattern || DEFAULT_REFRESH_TOKEN_PATTERN);
    this._mtlsGateway = opts.mtlsGateway;
  }
  _createClass(OAuthClient, [{
    key: "getServiceUri",
    value: function getServiceUri() {
      return this._serviceUri;
    }
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this._discovery.getMetadata();
            case 2:
              this._metadata = _context.sent;
              return _context.abrupt("return", this._metadata);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getMetadata() {
        return _getMetadata.apply(this, arguments);
      }
      return getMetadata;
    }()
  }, {
    key: "getMetadataSync",
    value: function getMetadataSync() {
      if (!this._metadata) {
        throw new SyncCallNotPossible("Asynchronous method getMetadata must be invoked prior to synchronous invocation");
      }
      return this._metadata;
    }
  }, {
    key: "getIssuerList",
    value: function () {
      var _getIssuerList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var metadata, issuerList;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.getMetadata();
            case 2:
              metadata = _context2.sent;
              issuerList = [metadata.issuer];
              if (metadata.access_token_issuer) {
                issuerList.push(metadata.access_token_issuer);
              }
              if (this._customIssuer) {
                issuerList.push(this._customIssuer);
              }
              return _context2.abrupt("return", issuerList);
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getIssuerList() {
        return _getIssuerList.apply(this, arguments);
      }
      return getIssuerList;
    }()
  }, {
    key: "getSupportedAcrValues",
    value: function () {
      var _getSupportedAcrValues = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.getMetadata();
            case 2:
              _context3.t0 = _context3.sent.acr_values_supported;
              if (_context3.t0) {
                _context3.next = 5;
                break;
              }
              _context3.t0 = [];
            case 5:
              return _context3.abrupt("return", _context3.t0);
            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getSupportedAcrValues() {
        return _getSupportedAcrValues.apply(this, arguments);
      }
      return getSupportedAcrValues;
    }()
  }, {
    key: "getSupportedAcrValuesSync",
    value: function getSupportedAcrValuesSync() {
      return this.getMetadataSync().acr_values_supported || [];
    }
  }, {
    key: "getUserInfoUri",
    value: function () {
      var _getUserInfoUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.getMetadata();
            case 2:
              return _context4.abrupt("return", _context4.sent.userinfo_endpoint);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getUserInfoUri() {
        return _getUserInfoUri.apply(this, arguments);
      }
      return getUserInfoUri;
    }()
  }, {
    key: "getEndSessionUri",
    value: function () {
      var _getEndSessionUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.getMetadata();
            case 2:
              return _context5.abrupt("return", _context5.sent.end_session_endpoint);
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getEndSessionUri() {
        return _getEndSessionUri.apply(this, arguments);
      }
      return getEndSessionUri;
    }()
  }, {
    key: "getEndSessionUriSync",
    value: function getEndSessionUriSync() {
      return this.getMetadataSync().end_session_endpoint;
    }
  }, {
    key: "getCheckSessionIframeUri",
    value: function () {
      var _getCheckSessionIframeUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var uri;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.getMetadata();
            case 2:
              uri = _context6.sent.check_session_iframe;
              return _context6.abrupt("return", this._replaceMtlsGatewayIfNeeded(uri));
            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getCheckSessionIframeUri() {
        return _getCheckSessionIframeUri.apply(this, arguments);
      }
      return getCheckSessionIframeUri;
    }()
  }, {
    key: "getAuthorizationUri",
    value: function () {
      var _getAuthorizationUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(reponseType, redirectUri, clientId, acrValues) {
        var scope,
          _args7 = arguments;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              scope = _args7.length > 4 && _args7[4] !== undefined ? _args7[4] : null;
              _context7.next = 3;
              return this.getMetadata();
            case 3:
              return _context7.abrupt("return", this.getAuthorizationUriSync(reponseType, redirectUri, clientId, acrValues, scope));
            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getAuthorizationUri(_x, _x2, _x3, _x4) {
        return _getAuthorizationUri.apply(this, arguments);
      }
      return getAuthorizationUri;
    }()
  }, {
    key: "getAuthorizationUriSync",
    value: function getAuthorizationUriSync(reponseType, redirectUri, clientId, acrValues) {
      var scope = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      if (clientId && clientId.client_id) {
        // TODO Workaround for backward compatibility where clientCredentials object was passed instead of plain clientId
        clientId = clientId.client_id;
      }
      var endpoint = this._replaceMtlsGatewayIfNeeded(this.getMetadataSync().authorization_endpoint);
      var authzUri = "".concat(endpoint, "?");
      authzUri += "response_type=".concat(encodeURIComponent(reponseType), "&");
      authzUri += "redirect_uri=".concat(encodeURIComponent(redirectUri), "&");
      authzUri += "client_id=".concat(encodeURIComponent(clientId), "&");
      authzUri += "scope=".concat(encodeURIComponent(this._getOidcScope(scope)));
      if (acrValues) {
        var supportedAcrValues = this.getSupportedAcrValuesSync();
        if (supportedAcrValues && supportedAcrValues.length > 0) {
          // TODO Workaround for renaming of "medium" acrValue on G02 server
          var requestedValuesStr = acrValues.toString();
          if (supportedAcrValues.includes("medium")) {
            requestedValuesStr = requestedValuesStr.replace("standard", "medium");
          } else if (supportedAcrValues.includes("standard")) {
            requestedValuesStr = requestedValuesStr.replace("medium", "standard");
          }
          // ...end of workaround
          var requestedValues = requestedValuesStr.split(" ");
          var transformedValues = [];
          requestedValues.forEach(function (requestedValue) {
            if (supportedAcrValues.includes(requestedValue)) {
              transformedValues.push(requestedValue);
            } else {
              var requestedValueOrd = Number(requestedValue);
              if (supportedAcrValues.includes(requestedValueOrd)) {
                transformedValues.push(requestedValueOrd);
              } else if (supportedAcrValues[requestedValueOrd]) {
                transformedValues.push(supportedAcrValues[requestedValueOrd]);
                // TODO Workaround to allow sending of word values to G01
              } else if ((requestedValueOrd = G02_ACR_VALUES_OLD.indexOf(requestedValue)) > -1 || (requestedValueOrd = G02_ACR_VALUES.indexOf(requestedValue)) > -1) {
                transformedValues.push(requestedValueOrd);
              }
              // ...end of workaround
            }
          });

          transformedValues = transformedValues.filter(function (p) {
            return p == null ? false : true;
          });
          // TODO Workaround for G01 which accepts only single acr value
          // and uses acr value ordering (thus lowest number is selected)
          if (transformedValues.length > 1 && !isNaN(transformedValues[0])) {
            transformedValues = [Math.min.apply(Math, _toConsumableArray(transformedValues))];
          }
          // ...end of workaround
          if (transformedValues.length > 0) {
            authzUri += "&acr_values=".concat(encodeURIComponent(transformedValues.join(" ")));
          }
        }
      }
      return authzUri;
    }
  }, {
    key: "grantAuthorizationCodeToken",
    value: function () {
      var _grantAuthorizationCodeToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(authorizationCode, clientCredentials, redirectUri) {
        var scope,
          params,
          _args8 = arguments;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              scope = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : null;
              params = {};
              params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_CODE;
              params[OAUTH_CODE] = authorizationCode;
              params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
              params[OAUTH_SCOPE] = this._getOidcScope(scope);
              if (redirectUri) {
                params[OAUTH_PARAM_REDIRECT_URI] = redirectUri;
              }
              _context8.next = 9;
              return this._grantToken(params, clientCredentials);
            case 9:
              return _context8.abrupt("return", _context8.sent);
            case 10:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function grantAuthorizationCodeToken(_x5, _x6, _x7) {
        return _grantAuthorizationCodeToken.apply(this, arguments);
      }
      return grantAuthorizationCodeToken;
    }()
  }, {
    key: "grantResourceOwnerPasswordCredentialsToken",
    value: function () {
      var _grantResourceOwnerPasswordCredentialsToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(username, password, clientCredentials) {
        var scope,
          params,
          _args9 = arguments;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              scope = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : null;
              params = {};
              params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_RESOURCE_OWNER_PASSWORD;
              params[OAUTH_USERNAME] = username;
              params[OAUTH_PASSWORD] = password;
              params[OAUTH_SCOPE] = this._getOidcScope(scope);
              _context9.next = 8;
              return this._grantToken(params, clientCredentials);
            case 8:
              return _context9.abrupt("return", _context9.sent);
            case 9:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function grantResourceOwnerPasswordCredentialsToken(_x8, _x9, _x10) {
        return _grantResourceOwnerPasswordCredentialsToken.apply(this, arguments);
      }
      return grantResourceOwnerPasswordCredentialsToken;
    }()
  }, {
    key: "grantImplicitFlowToken",
    value: function () {
      var _grantImplicitFlowToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              throw new BaseError("Method not implemented.");
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      function grantImplicitFlowToken() {
        return _grantImplicitFlowToken.apply(this, arguments);
      }
      return grantImplicitFlowToken;
    }()
  }, {
    key: "grantHybridFlowToken",
    value: function () {
      var _grantHybridFlowToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              throw new BaseError("Method not implemented.");
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));
      function grantHybridFlowToken() {
        return _grantHybridFlowToken.apply(this, arguments);
      }
      return grantHybridFlowToken;
    }()
  }, {
    key: "grantClientCredentialsToken",
    value: function () {
      var _grantClientCredentialsToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(clientCredentials) {
        var scope,
          params,
          _args12 = arguments;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              scope = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : null;
              params = {};
              params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_CLIENT_CREDENTIALS;
              params[OAUTH_SCOPE] = this._getOidcScope(scope);
              _context12.next = 6;
              return this._grantToken(params, clientCredentials);
            case 6:
              return _context12.abrupt("return", _context12.sent);
            case 7:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function grantClientCredentialsToken(_x11) {
        return _grantClientCredentialsToken.apply(this, arguments);
      }
      return grantClientCredentialsToken;
    }()
  }, {
    key: "refreshToken",
    value: function () {
      var _refreshToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_refreshToken, clientCredentials) {
        var scope,
          params,
          _args13 = arguments;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              scope = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : null;
              params = {};
              params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_REFRESH_TOKEN;
              params[OAUTH_REFRESH_TOKEN] = _refreshToken;
              params[OAUTH_SCOPE] = this._getOidcScope(scope);
              _context13.next = 7;
              return this._grantToken(params, clientCredentials);
            case 7:
              return _context13.abrupt("return", _context13.sent);
            case 8:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function refreshToken(_x12, _x13) {
        return _refreshToken2.apply(this, arguments);
      }
      return refreshToken;
    }()
  }, {
    key: "exchangeToken",
    value: function () {
      var _exchangeToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(token) {
        var tokenType,
          clientCredentials,
          scope,
          params,
          _args14 = arguments;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              tokenType = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : null;
              clientCredentials = _args14.length > 2 ? _args14[2] : undefined;
              scope = _args14.length > 3 && _args14[3] !== undefined ? _args14[3] : null;
              if (tokenType != null && _typeof(tokenType) === "object") {
                scope = clientCredentials;
                clientCredentials = tokenType;
                tokenType = null;
              }
              params = {};
              params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_QUALIFIED_EXCHANGE;
              params[OAUTH_SUBJECT_TOKEN] = token;
              if (tokenType === "idToken") {
                params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
              } else if (tokenType === "accessToken") {
                params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
              } else if (token.match(JWT_TOKEN_REGEX)) {
                // uuOidc by default uses JWT format only for idToken
                params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
              } else {
                params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
              }
              params[OAUTH_SCOPE] = this._getOidcScope(scope);
              _context14.next = 11;
              return this._grantToken(params, clientCredentials);
            case 11:
              return _context14.abrupt("return", _context14.sent);
            case 12:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function exchangeToken(_x14) {
        return _exchangeToken.apply(this, arguments);
      }
      return exchangeToken;
    }()
  }, {
    key: "delegateToken",
    value: function () {
      var _delegateToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(actorToken) {
        var actorTokenType,
          subjectToken,
          subjectTokenType,
          clientCredentials,
          scope,
          params,
          _args15 = arguments;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              actorTokenType = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : null;
              subjectToken = _args15.length > 2 ? _args15[2] : undefined;
              subjectTokenType = _args15.length > 3 && _args15[3] !== undefined ? _args15[3] : null;
              clientCredentials = _args15.length > 4 ? _args15[4] : undefined;
              scope = _args15.length > 5 && _args15[5] !== undefined ? _args15[5] : null;
              if (actorTokenType != null && actorTokenType !== "idToken" && actorTokenType !== "accessToken") {
                scope = clientCredentials;
                clientCredentials = subjectTokenType;
                subjectToken = actorTokenType;
                actorTokenType = null;
              }
              if (subjectTokenType != null && _typeof(subjectTokenType) === "object") {
                scope = clientCredentials;
                clientCredentials = subjectTokenType;
                subjectTokenType = null;
              }
              params = {};
              params[OAUTH_GRANT_TYPE] = OAUTH_GRANT_TYPE_QUALIFIED_EXCHANGE;
              params[OAUTH_ACTOR_TOKEN] = actorToken;
              params[OAUTH_SUBJECT_TOKEN] = subjectToken;
              if (actorTokenType === "idToken") {
                params[OAUTH_ACTOR_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
              } else if (actorTokenType === "accessToken") {
                params[OAUTH_ACTOR_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
              } else if (actorToken.match(JWT_TOKEN_REGEX)) {
                // uuOidc by default uses JWT format only for idToken
                params[OAUTH_ACTOR_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
              }
              if (subjectTokenType === "idToken") {
                params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
              } else if (subjectTokenType === "accessToken") {
                params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
              } else if (subjectToken.match(JWT_TOKEN_REGEX)) {
                // uuOidc by default uses JWT format only for idToken
                params[OAUTH_SUBJECT_TOKEN_TYPE] = OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
              }
              params[OAUTH_SCOPE] = this._getOidcScope(scope);
              _context15.next = 16;
              return this._grantToken(params, clientCredentials);
            case 16:
              return _context15.abrupt("return", _context15.sent);
            case 17:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function delegateToken(_x15) {
        return _delegateToken.apply(this, arguments);
      }
      return delegateToken;
    }()
  }, {
    key: "introspectToken",
    value: function () {
      var _introspectToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(token) {
        var tokenType,
          clientCredentials,
          metadata,
          introspectTokenUri,
          params,
          tokenTypeHint,
          headers,
          authnHeader,
          tokenMatch,
          result,
          _args16 = arguments;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              tokenType = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : null;
              clientCredentials = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : null;
              if (tokenType != null && _typeof(tokenType) === "object") {
                clientCredentials = tokenType;
                tokenType = null;
              }
              _context16.next = 5;
              return this.getMetadata();
            case 5:
              metadata = _context16.sent;
              introspectTokenUri = metadata.token_introspection_endpoint;
              params = {};
              params[OAUTH_PARAM_TOKEN] = token;
              tokenTypeHint = tokenType || this._getTokenTypeHint(token);
              if (tokenTypeHint) {
                params[OAUTH_PARAM_TOKEN_TYPE_HINT] = tokenTypeHint;
              }
              headers = {};
              headers["Content-Type"] = MEDIA_FORM_ENCODED;
              headers["Accept"] = MEDIA_JSON;
              if (!clientCredentials) {
                _context16.next = 19;
                break;
              }
              _context16.next = 17;
              return this._createClientAuthnHeader(clientCredentials);
            case 17:
              authnHeader = _context16.sent;
              // TODO Temporary workaround until server accepts client token in header
              if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
                params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
                params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
                params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
              } else {
                headers["Authorization"] = authnHeader;
              }
            case 19:
              result = null;
              _context16.prev = 20;
              _context16.next = 23;
              return this._client.post(introspectTokenUri, params, {
                headers: headers
              });
            case 23:
              result = _context16.sent;
              _context16.next = 33;
              break;
            case 26:
              _context16.prev = 26;
              _context16.t0 = _context16["catch"](20);
              if (!(_context16.t0 instanceof ApplicationError)) {
                _context16.next = 32;
                break;
              }
              throw new InvalidCredentials("Invalid credentials.", _context16.t0);
            case 32:
              throw new AuthenticationError("Authentication failed.", _context16.t0);
            case 33:
              if (result.active) {
                _context16.next = 35;
                break;
              }
              throw new InvalidCredentials("Invalid credentials.");
            case 35:
              return _context16.abrupt("return", result.data);
            case 36:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[20, 26]]);
      }));
      function introspectToken(_x16) {
        return _introspectToken.apply(this, arguments);
      }
      return introspectToken;
    }()
  }, {
    key: "revokeToken",
    value: function () {
      var _revokeToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(token) {
        var clientCredentials,
          metadata,
          revokeTokenUri,
          params,
          tokenTypeHint,
          headers,
          authnHeader,
          tokenMatch,
          result,
          _args17 = arguments;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              clientCredentials = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : null;
              _context17.next = 3;
              return this.getMetadata();
            case 3:
              metadata = _context17.sent;
              revokeTokenUri = metadata.token_revocation_endpoint;
              params = {};
              params[OAUTH_PARAM_TOKEN] = token;
              tokenTypeHint = this._getTokenTypeHint(token);
              if (tokenTypeHint) {
                params[OAUTH_PARAM_TOKEN_TYPE_HINT] = tokenTypeHint;
              }
              headers = {};
              headers["Content-Type"] = MEDIA_FORM_ENCODED;
              headers["Accept"] = MEDIA_JSON;
              if (!clientCredentials) {
                _context17.next = 17;
                break;
              }
              _context17.next = 15;
              return this._createClientAuthnHeader(clientCredentials);
            case 15:
              authnHeader = _context17.sent;
              // TODO Temporary workaround until server accepts client token in header
              if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
                params[OAUTH_CLIENT_ID] = clientCredentials[OAUTH_CLIENT_ID];
                params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
                params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
              } else {
                headers["Authorization"] = authnHeader;
              }
            case 17:
              result = null;
              _context17.prev = 18;
              _context17.next = 21;
              return this._client.post(revokeTokenUri, params, {
                headers: headers
              });
            case 21:
              result = _context17.sent;
              _context17.next = 31;
              break;
            case 24:
              _context17.prev = 24;
              _context17.t0 = _context17["catch"](18);
              if (!(_context17.t0 instanceof ApplicationError)) {
                _context17.next = 30;
                break;
              }
              throw new InvalidCredentials("Invalid credentials.", _context17.t0);
            case 30:
              throw new AuthenticationError("Authentication failed.", _context17.t0);
            case 31:
              return _context17.abrupt("return", result.data);
            case 32:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this, [[18, 24]]);
      }));
      function revokeToken(_x17) {
        return _revokeToken.apply(this, arguments);
      }
      return revokeToken;
    }()
  }, {
    key: "parseToken",
    value: function () {
      var _parseToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(token) {
        var tokenType,
          verify,
          clientCredentials,
          claims,
          _args18 = arguments;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              tokenType = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : null;
              verify = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : true;
              clientCredentials = _args18.length > 3 && _args18[3] !== undefined ? _args18[3] : null;
              if (tokenType != null && _typeof(tokenType) === "object") {
                clientCredentials = tokenType;
                verify = true;
                tokenType = null;
              } else if (typeof tokenType === "boolean") {
                clientCredentials = _typeof(verify) === "object" ? verify : null;
                verify = tokenType;
                tokenType = null;
              } else if (_typeof(verify) === "object") {
                clientCredentials = verify;
                verify = true;
              }
              if (!token.match(JWT_TOKEN_REGEX)) {
                _context18.next = 10;
                break;
              }
              _context18.next = 7;
              return this._jwt.parseToken(token, verify);
            case 7:
              claims = _context18.sent;
              _context18.next = 14;
              break;
            case 10:
              _context18.next = 12;
              return this.introspectToken(token, tokenType, clientCredentials);
            case 12:
              claims = _context18.sent;
              if (verify) {
                this._jwt.verifyExpiration(claims);
              }
            case 14:
              return _context18.abrupt("return", claims);
            case 15:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function parseToken(_x18) {
        return _parseToken.apply(this, arguments);
      }
      return parseToken;
    }()
  }, {
    key: "cacheToken",
    value: function cacheToken(tokenKey, expireAt, token) {
      expireAt = expireAt - this._tokenTimeLeeway * 2;
      var ttl = expireAt * 1000 - Date.now();
      if (ttl > 0) {
        this._tokenCache.set(tokenKey, token, ttl);
      }
    }
  }, {
    key: "getToken",
    value: function getToken(tokenKey) {
      return this._tokenCache.get(tokenKey);
    }
  }, {
    key: "deleteToken",
    value: function deleteToken(tokenKey) {
      return this._tokenCache.delete(tokenKey);
    }
  }, {
    key: "listTokens",
    value: function listTokens(callback) {
      this._tokenCache.forEach(callback);
    }

    // ======================== Private methods ================================
  }, {
    key: "_grantToken",
    value: function () {
      var _grantToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(params) {
        var credentials,
          metadata,
          grantTokenUri,
          headers,
          authnHeader,
          tokenMatch,
          result,
          _args19 = arguments;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              credentials = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : null;
              _context19.next = 3;
              return this.getMetadata();
            case 3:
              metadata = _context19.sent;
              grantTokenUri = metadata.token_endpoint;
              headers = {};
              headers["Content-Type"] = MEDIA_FORM_ENCODED;
              headers["Accept"] = MEDIA_JSON;
              if (!credentials) {
                _context19.next = 13;
                break;
              }
              _context19.next = 11;
              return this._createClientAuthnHeader(credentials);
            case 11:
              authnHeader = _context19.sent;
              // TODO Temporary workaround until server accepts client token in header
              if (tokenMatch = authnHeader.match(/^Bearer (.*)/)) {
                params[OAUTH_CLIENT_ID] = credentials[OAUTH_CLIENT_ID];
                params[OAUTH_CLIENT_ASSERTION] = tokenMatch[1];
                params[OAUTH_CLIENT_ASSERTION_TYPE] = OAUTH_CLIENT_ASSERTION_BEARER;
              } else {
                headers["Authorization"] = authnHeader;
              }
            case 13:
              result = null;
              _context19.prev = 14;
              _context19.next = 17;
              return this._client.post(grantTokenUri, params, {
                headers: headers
              });
            case 17:
              result = _context19.sent;
              _context19.next = 27;
              break;
            case 20:
              _context19.prev = 20;
              _context19.t0 = _context19["catch"](14);
              if (!(_context19.t0 instanceof ApplicationError)) {
                _context19.next = 26;
                break;
              }
              throw new InvalidCredentials("Invalid credentials.", _context19.t0);
            case 26:
              throw new AuthenticationError("Authentication failed.", _context19.t0);
            case 27:
              return _context19.abrupt("return", result.data);
            case 28:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this, [[14, 20]]);
      }));
      function _grantToken(_x19) {
        return _grantToken2.apply(this, arguments);
      }
      return _grantToken;
    }()
  }, {
    key: "_createClientAuthnHeader",
    value: function () {
      var _createClientAuthnHeader2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(credentials) {
        var authnHeader, metadata, issuedAt, claims, token, username, password;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              authnHeader = null;
              if (!credentials[CLIENT_PRIVATE_KEY]) {
                _context20.next = 13;
                break;
              }
              _context20.next = 4;
              return this.getMetadata();
            case 4:
              metadata = _context20.sent;
              issuedAt = Math.round(Date.now() / 1000);
              claims = {
                jti: Math.random().toString(16).substring(2, 10),
                iat: issuedAt,
                exp: issuedAt + CLIENT_TOKEN_TTL,
                aud: metadata.token_endpoint,
                iss: credentials[OAUTH_CLIENT_ID],
                sub: credentials[OAUTH_CLIENT_ID]
              };
              _context20.next = 9;
              return this._jwt.createToken(claims, credentials[CLIENT_PRIVATE_KEY]);
            case 9:
              token = _context20.sent;
              authnHeader = "Bearer ".concat(token);
              _context20.next = 17;
              break;
            case 13:
              username = credentials[OAUTH_CLIENT_ID];
              password = credentials[OAUTH_CLIENT_SECRET]; // avoid/encode ':' -  is reserved for basic authentication
              username = encodeURIComponent(username);
              authnHeader = "Basic ".concat(Base64.encode("".concat(username, ":").concat(password)));
            case 17:
              return _context20.abrupt("return", authnHeader);
            case 18:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function _createClientAuthnHeader(_x20) {
        return _createClientAuthnHeader2.apply(this, arguments);
      }
      return _createClientAuthnHeader;
    }()
  }, {
    key: "_getOidcScope",
    value: function _getOidcScope(scope) {
      var oidcScope = null;
      if (Array.isArray(scope)) {
        oidcScope = "".concat(this._defaultScope, " ").concat(scope.join(" ")).trim();
      } else if (scope) {
        oidcScope = "".concat(this._defaultScope, " ").concat(scope);
      } else {
        oidcScope = this._defaultScope;
      }
      oidcScope = LocalDomainScopeHandler.transformScope(oidcScope);
      return oidcScope;
    }
  }, {
    key: "_getTokenTypeHint",
    value: function _getTokenTypeHint(token) {
      if (this._accessTokenPattern.test(token)) {
        return OAUTH_TOKEN_TYPE_QUALIFIED_ACCESS_TOKEN;
      } else if (this._refreshTokenPattern.test(token)) {
        return OAUTH_TOKEN_TYPE_QUALIFIED_REFRESH_TOKEN;
      } else if (JWT_TOKEN_REGEX.test(token)) {
        // uuOidc by default uses JWT format only for idToken
        return OAUTH_TOKEN_TYPE_QUALIFIED_ID_TOKEN;
      } else {
        return null;
      }
    }
  }, {
    key: "_replaceMtlsGatewayIfNeeded",
    value: function _replaceMtlsGatewayIfNeeded(uri) {
      if (this._mtlsGateway) {
        var uriBuilder = new UriBuilder().parse(uri);
        var newGateway = this._mtlsGateway;
        return uriBuilder.setGateway(newGateway).toString();
      }
      return uri;
    }
  }]);
  return OAuthClient;
}();
module.exports = OAuthClient;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6).Uri;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var _require = __webpack_require__(7),
  BaseError = _require.BaseError;
var SyncCallNotPossible = /*#__PURE__*/function (_BaseError) {
  _inherits(SyncCallNotPossible, _BaseError);
  var _super = _createSuper(SyncCallNotPossible);
  function SyncCallNotPossible(message) {
    var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, SyncCallNotPossible);
    return _super.call(this, message, cause);
  }
  return _createClass(SyncCallNotPossible);
}(BaseError);
module.exports = SyncCallNotPossible;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(9),
  AppClient = _require.AppClient;
var _require2 = __webpack_require__(7),
  BaseError = _require2.BaseError,
  LruCache = _require2.LruCache;
var _require3 = __webpack_require__(9),
  PerflogHandler = _require3.PerflogHandler,
  RemoteErrorHandler = _require3.RemoteErrorHandler,
  TransformParametersHandler = _require3.TransformParametersHandler;
var APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, TransformParametersHandler];
var APP_CLIENT_INTERCEPTORS_NO_PERFLOG = [RemoteErrorHandler, TransformParametersHandler];
var OIDC_WELL_KNOWN_DISCOVERY_PATH = ".well-known/openid-configuration";
var DISCOVERY_CACHE_SIZE = 16;
var DEFAULT_DISCOVERY_CACHE_TTL = 60 * 60;
var DISCOVERY_CACHE_STORAGE_KEY = "uu_app_oidc_cache_discovery";
var DISCOVERY_CACHE = new LruCache({
  maxSize: DISCOVERY_CACHE_SIZE,
  localStorageKey: DISCOVERY_CACHE_STORAGE_KEY
});
var Discovery = /*#__PURE__*/function () {
  function Discovery(serviceUri) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Discovery);
    if (!serviceUri) {
      throw new BaseError("Service URI must be defined");
    }
    var discoveryPath = opts.discoveryPath || OIDC_WELL_KNOWN_DISCOVERY_PATH;
    this._discoveryUri = "".concat(serviceUri, "/").concat(discoveryPath.replace(/^\//, ""));
    this._discoveryCacheTtl = (opts.discoveryCacheTtl ? Number(opts.discoveryCacheTtl) : DEFAULT_DISCOVERY_CACHE_TTL) * 1000;
    var perflogEnabled = typeof opts.perflogEnabled === "boolean" ? opts.perflogEnabled : true;
    var interceptors = perflogEnabled ? APP_CLIENT_INTERCEPTORS : APP_CLIENT_INTERCEPTORS_NO_PERFLOG;
    this._client = new AppClient(Object.assign(opts, {
      interceptors: interceptors
    }));
  }
  _createClass(Discovery, [{
    key: "getMetadata",
    value: function () {
      var _getMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var refresh,
          metadata,
          result,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              refresh = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;
              metadata = DISCOVERY_CACHE.get(this._discoveryUri);
              if (!(!metadata || refresh)) {
                _context.next = 8;
                break;
              }
              _context.next = 5;
              return this._client.get(this._discoveryUri);
            case 5:
              result = _context.sent;
              metadata = result.data;
              DISCOVERY_CACHE.set(this._discoveryUri, metadata, this._discoveryCacheTtl);
            case 8:
              return _context.abrupt("return", metadata);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getMetadata() {
        return _getMetadata.apply(this, arguments);
      }
      return getMetadata;
    }()
  }]);
  return Discovery;
}();
module.exports = Discovery;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Crypto = typeof window === "undefined" ? __webpack_require__(21) : window.crypto;
// With Node.js 15-18 webcrypto is experimental and available via different module than on 19+
var SubtleCrypto = Crypto && Crypto.subtle || Crypto && Crypto.webcrypto && Crypto.webcrypto.subtle;
var _require = __webpack_require__(5),
  InvalidCredentials = _require.InvalidCredentials;
var _require2 = __webpack_require__(7),
  Base64 = _require2.Base64,
  Json = _require2.Json;
var Jwks = __webpack_require__(22);
var JWT_TOKEN_REGEX = /^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$/;
var DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;
var DEFAULT_TOKEN_TYPE = "JWT";
var DEFAULT_TOKEN_SIGN_ALG = "RS256";
var DEFAULT_PUBLIC_KEY_FORMAT = "jwk";
var DEFAULT_PRIVATE_KEY_FORMAT = "pkcs8";
var DEFAULT_KEY_ALGORITHM = "RSASSA-PKCS1-v1_5";
var DEFAULT_KEY_DIGEST = "SHA-256";
var DEFAULT_KEY_PARAMS = {
  name: DEFAULT_KEY_ALGORITHM,
  hash: {
    name: DEFAULT_KEY_DIGEST
  }
};
var Jwt = /*#__PURE__*/function () {
  function Jwt(discovery) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Jwt);
    if (!discovery) {
      throw new BaseError("Instance of discovery must be provided");
    }
    this._discovery = discovery;
    this._jwks = new Jwks(this._discovery, opts);
    this._customIssuer = opts.issuer;
    this._tokenTimeLeeway = opts.tokenTimeLeeway ? Number(opts.tokenTimeLeeway) : DEFAULT_TOKEN_TIME_LEEWAY;
    this._disableWebcryptoApi = typeof opts.disableWebcryptoApi === "boolean" ? opts.disableWebcryptoApi : false;
  }
  _createClass(Jwt, [{
    key: "parseToken",
    value: function () {
      var _parseToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(token) {
        var verify,
          verifyOpts,
          tokenParts,
          headers,
          claims,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              verify = _args.length > 1 && _args[1] !== undefined ? _args[1] : true;
              verifyOpts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              if (!(!token || !token.match(JWT_TOKEN_REGEX))) {
                _context.next = 4;
                break;
              }
              throw new InvalidCredentials("Unsupported token format.");
            case 4:
              tokenParts = token.split(".");
              _context.prev = 5;
              headers = Json.parse(Base64.urlSafeDecode(tokenParts[0]));
              claims = Json.parse(Base64.urlSafeDecode(tokenParts[1]));
              _context.next = 13;
              break;
            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](5);
              throw new InvalidCredentials("Parsing of token failed.", _context.t0);
            case 13:
              if (!verify) {
                _context.next = 16;
                break;
              }
              _context.next = 16;
              return this._verifyToken(headers, claims, tokenParts, verifyOpts);
            case 16:
              return _context.abrupt("return", claims);
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[5, 10]]);
      }));
      function parseToken(_x) {
        return _parseToken.apply(this, arguments);
      }
      return parseToken;
    }()
  }, {
    key: "createToken",
    value: function () {
      var _createToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(claims, privateKey) {
        var headers, signedData, signature, cryptoKey, JSRSASIGN, requireName, sig;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              headers = {
                alg: DEFAULT_TOKEN_SIGN_ALG,
                typ: DEFAULT_TOKEN_TYPE
              };
              signedData = Base64.urlSafeEncode(Json.stringify(headers)) + "." + Base64.urlSafeEncode(Json.stringify(claims));
              if (!(SubtleCrypto && !this._disableWebcryptoApi)) {
                _context2.next = 13;
                break;
              }
              if (privateKey.includes("RSA PRIVATE KEY")) {
                // This is for backward compatibility with applications which were initialized
                // using "node-rsa" library generating private key in PKCS#1 format, as native
                // SubtleCrypto API supports only PKCS#8 format.
                privateKey = Crypto.createPrivateKey(privateKey);
                privateKey = privateKey.export({
                  format: "pem",
                  type: "pkcs8"
                });
              }
              privateKey = Base64.decode(privateKey.split("\n").slice(1, -1).join(), "binary");
              _context2.next = 7;
              return SubtleCrypto.importKey(DEFAULT_PRIVATE_KEY_FORMAT, privateKey, DEFAULT_KEY_PARAMS, true, ["sign"]);
            case 7:
              cryptoKey = _context2.sent;
              _context2.next = 10;
              return SubtleCrypto.sign(DEFAULT_KEY_PARAMS, cryptoKey, Buffer.from(signedData));
            case 10:
              signature = _context2.sent;
              _context2.next = 25;
              break;
            case 13:
              if (!(typeof window === "undefined")) {
                _context2.next = 18;
                break;
              }
              // TODO Workaround mainly for jest which cannot handle import.
              // Require must be done via variable, else webpack will bundle
              // jsrasing into library instead of using external chunk.
              requireName = "jsrsasign";
              JSRSASIGN = __webpack_require__(23)(requireName);
              _context2.next = 21;
              break;
            case 18:
              _context2.next = 20;
              return __webpack_require__.e(/* import() */ 0).then(__webpack_require__.t.bind(null, 43, 7));
            case 20:
              JSRSASIGN = _context2.sent;
            case 21:
              sig = new JSRSASIGN.KJUR.crypto.Signature({
                alg: "SHA256withRSA"
              });
              sig.init(privateKey);
              sig.updateString(signedData);
              signature = Buffer.from(sig.sign(), "hex");
            case 25:
              return _context2.abrupt("return", signedData + "." + Base64.urlSafeEncode(signature));
            case 26:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function createToken(_x2, _x3) {
        return _createToken.apply(this, arguments);
      }
      return createToken;
    }()
  }, {
    key: "isExpired",
    value: function isExpired(claims) {
      var leeway = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      leeway = leeway != null ? leeway : this._tokenTimeLeeway;
      return claims.exp && claims.exp < Date.now() / 1000 - leeway;
    }
  }, {
    key: "verifyExpiration",
    value: function verifyExpiration(claims) {
      var leeway = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (this.isExpired(claims, leeway)) {
        throw new InvalidCredentials("Token is expired.");
      }
    }
  }, {
    key: "_verifyToken",
    value: function () {
      var _verifyToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(headers, claims, tokenParts) {
        var verifyOpts,
          expectedIssuer,
          metadata,
          publicKey,
          expectedAlgorithm,
          _metadata,
          signedData,
          signature,
          isValid,
          cryptoKey,
          JSRSASIGN,
          requireName,
          sig,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              verifyOpts = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};
              this.verifyExpiration(claims, verifyOpts && verifyOpts.leeway);
              expectedIssuer = verifyOpts && verifyOpts.issuer;
              if (expectedIssuer) {
                _context3.next = 12;
                break;
              }
              _context3.next = 6;
              return this._discovery.getMetadata();
            case 6:
              metadata = _context3.sent;
              expectedIssuer = [metadata.issuer];
              if (metadata.access_token_issuer) {
                expectedIssuer.push[metadata.access_token_issuer];
              }
              if (this._customIssuer) {
                expectedIssuer.push[this._customIssuer];
              }
              _context3.next = 13;
              break;
            case 12:
              if (!Array.isArray(expectedIssuer)) {
                expectedIssuer = [expectedIssuer];
              }
            case 13:
              if (expectedIssuer.includes(claims.iss)) {
                _context3.next = 15;
                break;
              }
              throw new InvalidCredentials("Unsupported issuer.");
            case 15:
              publicKey = verifyOpts && verifyOpts.publicKey;
              if (publicKey) {
                _context3.next = 20;
                break;
              }
              _context3.next = 19;
              return this._jwks.getPublicKeyData(headers.kid);
            case 19:
              publicKey = _context3.sent;
            case 20:
              expectedAlgorithm = publicKey.alg;
              if (expectedAlgorithm) {
                _context3.next = 27;
                break;
              }
              _context3.next = 24;
              return this._discovery.getMetadata();
            case 24:
              _metadata = _context3.sent;
              expectedAlgorithm = (_metadata.id_token_signing_alg_values_supported || [])[0];
              if (!expectedAlgorithm) {
                expectedAlgorithm = DEFAULT_TOKEN_SIGN_ALG;
              }
            case 27:
              if (!(headers.alg != DEFAULT_TOKEN_SIGN_ALG)) {
                _context3.next = 29;
                break;
              }
              throw new InvalidCredentials("Unexpected signature algorithm.");
            case 29:
              signedData = tokenParts[0] + "." + tokenParts[1];
              signature = Base64.decode(tokenParts[2], "binary");
              if (!(SubtleCrypto && !this._disableWebcryptoApi)) {
                _context3.next = 46;
                break;
              }
              _context3.prev = 32;
              _context3.next = 35;
              return SubtleCrypto.importKey(DEFAULT_PUBLIC_KEY_FORMAT, publicKey, DEFAULT_KEY_PARAMS, false, ['verify']);
            case 35:
              cryptoKey = _context3.sent;
              _context3.next = 38;
              return SubtleCrypto.verify(DEFAULT_KEY_PARAMS, cryptoKey, signature, Buffer.from(signedData));
            case 38:
              isValid = _context3.sent;
              _context3.next = 44;
              break;
            case 41:
              _context3.prev = 41;
              _context3.t0 = _context3["catch"](32);
              throw new InvalidCredentials("Unable to verify signature.", _context3.t0);
            case 44:
              _context3.next = 66;
              break;
            case 46:
              if (!(typeof window === "undefined")) {
                _context3.next = 51;
                break;
              }
              // TODO Workaround mainly for jest which cannot handle import.
              // Require must be done via variable, else webpack will bundle
              // jsrasing into library instead of using external chunk.
              requireName = "jsrsasign";
              JSRSASIGN = __webpack_require__(23)(requireName);
              _context3.next = 54;
              break;
            case 51:
              _context3.next = 53;
              return __webpack_require__.e(/* import() */ 0).then(__webpack_require__.t.bind(null, 43, 7));
            case 53:
              JSRSASIGN = _context3.sent;
            case 54:
              _context3.prev = 54;
              signature = Buffer.from(signature).toString('hex');
              publicKey = JSRSASIGN.KEYUTIL.getKey(publicKey);
              sig = new JSRSASIGN.KJUR.crypto.Signature({
                alg: "SHA256withRSA"
              });
              sig.init(publicKey);
              sig.updateString(signedData);
              isValid = sig.verify(signature);
              _context3.next = 66;
              break;
            case 63:
              _context3.prev = 63;
              _context3.t1 = _context3["catch"](54);
              throw new InvalidCredentials("Unable to verify signature.", _context3.t1);
            case 66:
              if (isValid) {
                _context3.next = 68;
                break;
              }
              throw new InvalidCredentials("Invalid token signature.");
            case 68:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[32, 41], [54, 63]]);
      }));
      function _verifyToken(_x4, _x5, _x6) {
        return _verifyToken2.apply(this, arguments);
      }
      return _verifyToken;
    }()
  }]);
  return Jwt;
}();
module.exports = Jwt;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16).Buffer))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(18);
var ieee754 = __webpack_require__(19);
var isArray = __webpack_require__(20);
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();
function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42 &&
    // typed array instances can be augmented
    typeof arr.subarray === 'function' &&
    // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}
function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }
  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};
function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};
if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }
  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}
function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};
Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }
  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
        return asciiWrite(this, string, offset, length);
      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}
function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var g;

// This works in non-strict mode
g = function () {
  return this;
}();
try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}

/***/ }),
/* 19 */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

var toString = {}.toString;
module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(7),
  BaseError = _require.BaseError,
  LruCache = _require.LruCache;
var _require2 = __webpack_require__(9),
  AppClient = _require2.AppClient;
var _require3 = __webpack_require__(5),
  InvalidCredentials = _require3.InvalidCredentials;
var _require4 = __webpack_require__(9),
  PerflogHandler = _require4.PerflogHandler,
  RemoteErrorHandler = _require4.RemoteErrorHandler,
  TransformParametersHandler = _require4.TransformParametersHandler;
var APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, TransformParametersHandler];
var APP_CLIENT_INTERCEPTORS_NO_PERFLOG = [RemoteErrorHandler, TransformParametersHandler];
var JWKS_CACHE_SIZE = 16;
var DEFAULT_JWKS_CACHE_TTL = 60 * 60;
var JWKS_CACHE_STORAGE_KEY = "uu_app_oidc_cache_jwks";
var JWKS_CACHE = new LruCache({
  maxSize: JWKS_CACHE_SIZE,
  localStorageKey: JWKS_CACHE_STORAGE_KEY
});
var Jwks = /*#__PURE__*/function () {
  function Jwks(discovery) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Jwks);
    if (!discovery) {
      throw new BaseError("Instance of discovery must be provided");
    }
    this._discovery = discovery;
    this._jwksCacheTtl = (opts.jwksCacheTtl ? Number(opts.jwksCacheTtl) : DEFAULT_JWKS_CACHE_TTL) * 1000;
    var perflogEnabled = typeof opts.perflogEnabled === "boolean" ? opts.perflogEnabled : true;
    var interceptors = perflogEnabled ? APP_CLIENT_INTERCEPTORS : APP_CLIENT_INTERCEPTORS_NO_PERFLOG;
    this._client = new AppClient(Object.assign(opts, {
      interceptors: interceptors
    }));
  }
  _createClass(Jwks, [{
    key: "getPublicKeyData",
    value: function () {
      var _getPublicKeyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(kid) {
        var jwks, publicKeyData;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.getPublicKeySet();
            case 2:
              jwks = _context.sent;
              publicKeyData = jwks && jwks.keys.find(function (pk) {
                return pk.kid === kid;
              });
              if (publicKeyData) {
                _context.next = 17;
                break;
              }
              _context.next = 7;
              return this.getPublicKeySet(true);
            case 7:
              jwks = _context.sent;
              publicKeyData = jwks && jwks.keys.find(function (pk) {
                return pk.kid === kid;
              });
              if (publicKeyData) {
                _context.next = 17;
                break;
              }
              _context.t0 = InvalidCredentials;
              _context.t1 = "Unable to obtain public JWK key with jwk_id=".concat(kid, " from ");
              _context.next = 14;
              return this._discovery.getMetadata();
            case 14:
              _context.t2 = _context.sent.issuer;
              _context.t3 = _context.t1.concat.call(_context.t1, _context.t2, ".");
              throw new _context.t0(_context.t3);
            case 17:
              return _context.abrupt("return", publicKeyData);
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getPublicKeyData(_x) {
        return _getPublicKeyData.apply(this, arguments);
      }
      return getPublicKeyData;
    }()
  }, {
    key: "getPublicKeySet",
    value: function () {
      var _getPublicKeySet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var refresh,
          metadata,
          issuerUri,
          jwks,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              refresh = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : false;
              _context2.next = 3;
              return this._discovery.getMetadata();
            case 3:
              metadata = _context2.sent;
              issuerUri = metadata.issuer;
              jwks = JWKS_CACHE.get(issuerUri);
              if (!(!jwks || refresh)) {
                _context2.next = 11;
                break;
              }
              _context2.next = 9;
              return this._client.get(metadata.jwks_uri);
            case 9:
              jwks = _context2.sent.data;
              JWKS_CACHE.set(issuerUri, jwks, this._jwksCacheTtl);
            case 11:
              return _context2.abrupt("return", jwks);
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getPublicKeySet() {
        return _getPublicKeySet.apply(this, arguments);
      }
      return getPublicKeySet;
    }()
  }]);
  return Jwks;
}();
module.exports = Jwks;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 23;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(7),
  Config = _require.Config;
var LOCAL_DOMAIN_SCOPE_REPLACE_ENABLED = "uu_app_oidc_local_domain_scope_replace_enabled";
var LOCAL_DOMAIN_LIST = "uu_app_oidc_local_domain_list";
var DEFAULT_LOCAL_DOMAIN_LIST = "localhost,127.0.0.1";
var LOCAL_DOMAIN_SCOPE = "uu_app_oidc_local_domain_call_token_scope";
var DEFAULT_LOCAL_DOMAIN_SCOPE = "https:// http://";
var CALL_SCOPE = new RegExp("^https?://.*");

/**
 * Component for transforming scope so that localhost URIs are replaced
 * by broad scope allowing applications to do any token exchange without
 * requiring registered oidc client.
 */
var LocalDomainScopeHandler = /*#__PURE__*/function () {
  function LocalDomainScopeHandler() {
    _classCallCheck(this, LocalDomainScopeHandler);
    this._localDomainReplaceEnabled = Config.getBoolean(LOCAL_DOMAIN_SCOPE_REPLACE_ENABLED);
    if (this._localDomainReplaceEnabled == null) {
      this._localDomainReplaceEnabled = Config.isProfileActive("development", "test");
    }
    if (this._localDomainReplaceEnabled) {
      this._localDomainList = (Config.getString(LOCAL_DOMAIN_LIST) || DEFAULT_LOCAL_DOMAIN_LIST).split(",").map(function (domain) {
        return new RegExp("^https?://".concat(domain.trim(), "(:\\d{1,5})?($|/)"));
      });
      this._localDomainScope = Config.getString(LOCAL_DOMAIN_SCOPE) || DEFAULT_LOCAL_DOMAIN_SCOPE;
    }
  }
  _createClass(LocalDomainScopeHandler, [{
    key: "transformScope",
    value: function transformScope(scope) {
      var _this = this;
      if (!this._localDomainReplaceEnabled) {
        return scope;
      }
      var specialScopes = [];
      var externalCallScopes = [];
      var scopeParts = scope.split(" ");
      var _iterator = _createForOfIteratorHelper(scopeParts),
        _step;
      try {
        var _loop = function _loop() {
          var scopePart = _step.value;
          if (scopePart.match(CALL_SCOPE)) {
            if (!_this._localDomainList.find(function (domain) {
              return scopePart.match(domain);
            })) {
              externalCallScopes.push(scopePart);
            }
          } else {
            specialScopes.push(scopePart);
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (externalCallScopes.length > 0) {
        // In case there is any external scope, we cannot use generic scope
        return scope;
      } else {
        // Provide scope with all localhost scopes replaced by generic scope
        return "".concat(specialScopes.join(" "), " ").concat(this._localDomainScope);
      }
    }
  }]);
  return LocalDomainScopeHandler;
}();
module.exports = new LocalDomainScopeHandler();

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var _require = __webpack_require__(7),
  Config = _require.Config,
  Base64 = _require.Base64,
  BaseError = _require.BaseError,
  Digest = _require.Digest,
  Json = _require.Json;
var _require2 = __webpack_require__(12),
  UriBuilder = _require2.UriBuilder;
var _require3 = __webpack_require__(8),
  LoggerFactory = _require3.LoggerFactory;
var CoreAuthenticationService = __webpack_require__(5).AuthenticationService;
var CoreSession = __webpack_require__(5).Session;
var _require4 = __webpack_require__(5),
  Identity = _require4.Identity,
  ClientIdentity = _require4.ClientIdentity,
  ApplicationIdentity = _require4.ApplicationIdentity,
  UuAppKey = _require4.UuAppKey;
var EmptySession = __webpack_require__(26);
var ClientCredentialsProvider = __webpack_require__(27);
var JWT_CLAIM_UU_IDENTITY = "uuidentity";
var JWT_CLAIM_UU_IDENTITY_G01 = "uu_identity";
var JWT_CLAIM_NAME = "name";
var JWT_CLAIM_TOKEN_ID = "jti";
var JWT_CLAIM_SESSION_ID = "auth_id";
var JWT_CLAIM_SESSION_ID_G01 = "sid";
var JWT_CLAIM_AUTH_TIME = "auth_time";
var JWT_CLAIM_ISSUED_AT = "iat";
var JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE = "acr";
var JWT_CLAIM_UU_APP_KEY = "uuappkey";
var JWT_CLAIM_UU_APP_KEY_OLD = "appkey";
var JWT_CLAIM_LEVEL_OF_ASSURANCE = "loa";
var JWT_CLAIM_CLIENT_APP_ID = "client_app_id";
var JWT_CLAIM_CLIENT_APP_CODE = "client_app_code";
var JWT_CLAIM_CLIENT_UU_IDENTITY = "client_uuidentity";
var JWT_CLAIM_CLIENT_APP_NAME = "client_app_name";
var JWT_CLAIM_CLIENT_UU_APP_KEY = "client_uuappkey";
var JWT_CLAIM_CLIENT_UU_APP_KEY_OLD = "client_appkey";
var JWT_CLAIM_CLIENT_AUTH_LEVEL_OF_ASSURANCE = "client_acr";
var JWT_CLAIM_CLIENT_type = "client_uuidentity_type";
var JWT_CLAIM_CLIENT_URI = "client_uri";
var JWT_CLAIM_IDENTITY_TYPE = "uuidentity_type";
var JWT_CLAIM_IDENTITY_TYPE_G01 = "identity_type";
var JWT_CLAIM_ACCOUNT_TYPE = "uuidentity_account_type";
var JWT_CLAIM_ACTOR_IDENTITY = "act";
var OAUTH_TOKEN_TYPE_ID_TOKEN = "id_token";
var CLIENT_URI_URN = "urn:uuoidcclient:";
var ANONYMOUS_UUIDENTITY = "0-0";
var CONFIG_PREFIX = "uu_app_oidc_providers_";
var DEFAULT_SCOPE_MODE = "baseUri";
var DEFAULT_USE_TOKEN_EXCHANGE = true;
var DEFAULT_AUTH_LEVEL_OF_ASSURANCE = 1;
var DEFAULT_ACCOUNT_TYPE = "standard";
var Session = /*#__PURE__*/function (_CoreSession) {
  _inherits(Session, _CoreSession);
  var _super = _createSuper(Session);
  function Session(serviceName, oauthClient, supportedAcrValues) {
    var _this;
    var claims = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var idToken = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var accessToken = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    _classCallCheck(this, Session);
    var id = null;
    var authenticationId = null;
    var authenticationTime = null;
    var authenticationLevelOfAssurance = null;
    var identity = null;
    var actorIdentity = null;
    var clientIdentity = null;
    var applicationIdentity = null;
    var attributes = claims;
    var configPrefix = "".concat(CONFIG_PREFIX).concat(serviceName, "_");
    if (attributes) {
      id = attributes[JWT_CLAIM_TOKEN_ID];
      authenticationId = attributes[JWT_CLAIM_SESSION_ID] || attributes[JWT_CLAIM_SESSION_ID_G01];
      var epochAuthTime = attributes[JWT_CLAIM_AUTH_TIME] || attributes[JWT_CLAIM_ISSUED_AT];
      if (epochAuthTime) {
        authenticationTime = new Date(epochAuthTime * 1000);
      }
      var loa = attributes[JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE];
      if (loa == null) {
        authenticationLevelOfAssurance = DEFAULT_AUTH_LEVEL_OF_ASSURANCE;
      } else {
        if (supportedAcrValues.indexOf(loa) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(loa);
        } else if (supportedAcrValues.indexOf(loa.toString()) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(loa.toString());
        } else if (supportedAcrValues.indexOf(Number(loa.toString())) > -1) {
          authenticationLevelOfAssurance = supportedAcrValues.indexOf(Number(loa.toString()));
        } else {
          // TODO Fallback because oidcg02 now returns supported values as word but acr_value as number
          authenticationLevelOfAssurance = Number(loa.toString());
        }
      }
      var uuIdentity;
      var uuIdentityClaim = Config.getString("".concat(configPrefix, "uu_identity_claim"));
      if (uuIdentityClaim) {
        uuIdentity = attributes[uuIdentityClaim];
      } else {
        uuIdentity = attributes[JWT_CLAIM_UU_IDENTITY] || attributes[JWT_CLAIM_UU_IDENTITY_G01];
      }
      if (uuIdentity) {
        var levelOfAssurance = attributes[JWT_CLAIM_LEVEL_OF_ASSURANCE];
        var identityAcr = attributes[JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE];
        var uuAppKey = attributes[JWT_CLAIM_UU_APP_KEY] || attributes[JWT_CLAIM_UU_APP_KEY_OLD];
        if (uuAppKey) {
          uuAppKey = UuAppKey.parse(uuAppKey);
        }
        var name = attributes[JWT_CLAIM_NAME];
        if (uuIdentity === ANONYMOUS_UUIDENTITY) {
          authenticationLevelOfAssurance = 0;
        }
        var type = attributes[JWT_CLAIM_IDENTITY_TYPE] || attributes[JWT_CLAIM_IDENTITY_TYPE_G01];
        var accountType = attributes[JWT_CLAIM_ACCOUNT_TYPE] || DEFAULT_ACCOUNT_TYPE;
        var identityData = {
          name: name,
          levelOfAssurance: levelOfAssurance,
          type: type,
          authenticationLevelOfAssurance: identityAcr,
          uuAppKey: uuAppKey,
          accountType: accountType
        };
        identity = new Identity(uuIdentity, identityData);
        // TODO Remove after upgrade to uu_appg01_core-authentication 5.12
        identity.getAccountType = function () {
          return accountType;
        };
      }
      var appCode = attributes[JWT_CLAIM_CLIENT_APP_CODE];
      var appIdentity = attributes[JWT_CLAIM_CLIENT_UU_IDENTITY];
      if (appCode || appIdentity) {
        var appData = {};
        appData.id = attributes[JWT_CLAIM_CLIENT_APP_ID];
        appData.code = appCode;
        appData.name = attributes[JWT_CLAIM_CLIENT_APP_NAME];
        var _uuAppKey = attributes[JWT_CLAIM_CLIENT_UU_APP_KEY] || attributes[JWT_CLAIM_CLIENT_UU_APP_KEY_OLD];
        if (_uuAppKey) {
          appData.uuAppKey = UuAppKey.parse(_uuAppKey);
        }
        appData.authenticationLevelOfAssurance = attributes[JWT_CLAIM_CLIENT_AUTH_LEVEL_OF_ASSURANCE];
        appData.type = attributes[JWT_CLAIM_CLIENT_type];
        var clientUri = attributes[JWT_CLAIM_CLIENT_URI];
        if (clientUri) {
          appData.uri = clientUri;
          if (appData.uri && appData.uri.startsWith(CLIENT_URI_URN)) {
            var _appData$uri$replace$ = appData.uri.replace(CLIENT_URI_URN, "").split(/[:\/](.*)/),
              _appData$uri$replace$2 = _slicedToArray(_appData$uri$replace$, 2),
              product = _appData$uri$replace$2[0],
              asidawid = _appData$uri$replace$2[1];
            var _asidawid$split = asidawid.split(/[:\-]/),
              _asidawid$split2 = _slicedToArray(_asidawid$split, 2),
              asid = _asidawid$split2[0],
              awid = _asidawid$split2[1];
            if (!appData.code) {
              appData.code = product.toUpperCase().replace(/-/g, ".");
            }
            if (!appData.name) {
              appData.name = product.replace(/(-\w)/g, function (match) {
                return match[1].toUpperCase();
              });
            }
            var _product$split = product.split("-"),
              _product$split2 = _slicedToArray(_product$split, 3),
              vendor = _product$split2[0],
              app = _product$split2[1],
              subApp = _product$split2[2];
            appData.product = product;
            appData.vendor = vendor;
            appData.app = app;
            appData.subApp = subApp;
            appData.asid = asid;
            appData.awid = awid;
          }
        } else if (appData.code) {
          var _appData$code$toLower = appData.code.toLowerCase().split(/[\.\-_]/),
            _appData$code$toLower2 = _slicedToArray(_appData$code$toLower, 3),
            _vendor = _appData$code$toLower2[0],
            _app = _appData$code$toLower2[1],
            _subApp = _appData$code$toLower2[2];
          var _product = "".concat(_vendor, "-").concat(_app, "-").concat(_subApp);
          appData.vendor = _vendor;
          appData.app = _app;
          appData.subApp = _subApp;
          appData.product = _product;
          appData.uri = "".concat(CLIENT_URI_URN).concat(_product);
        }
        clientIdentity = new ClientIdentity(appIdentity, appData);
        applicationIdentity = new ApplicationIdentity(appIdentity, appData);
      }
      var actorIdentityClaim = attributes[JWT_CLAIM_ACTOR_IDENTITY];
      if (actorIdentityClaim) {
        var actorUuIdentity;
        var _uuIdentityClaim = Config.getString("".concat(configPrefix, "uu_identity_claim"));
        if (_uuIdentityClaim) {
          actorUuIdentity = actorIdentityClaim[_uuIdentityClaim];
        } else {
          actorUuIdentity = actorIdentityClaim[JWT_CLAIM_UU_IDENTITY] || attributes[JWT_CLAIM_UU_IDENTITY_G01];
        }
        var actorName = actorIdentityClaim[JWT_CLAIM_NAME];
        var actorType = actorIdentityClaim[JWT_CLAIM_IDENTITY_TYPE] || actorIdentityClaim[JWT_CLAIM_IDENTITY_TYPE_G01];
        var actorLoa = actorIdentityClaim[JWT_CLAIM_LEVEL_OF_ASSURANCE];
        var actorAcr = actorIdentityClaim[JWT_CLAIM_AUTH_LEVEL_OF_ASSURANCE];
        var actorUuAppKey = actorIdentityClaim[JWT_CLAIM_UU_APP_KEY] || actorIdentityClaim[JWT_CLAIM_UU_APP_KEY_OLD];
        if (actorUuAppKey) {
          actorUuAppKey = UuAppKey.parse(actorUuAppKey);
        }
        var actorAccountType = actorIdentityClaim[JWT_CLAIM_ACCOUNT_TYPE] || DEFAULT_ACCOUNT_TYPE;
        var actorIdentityData = {
          name: actorName,
          levelOfAssurance: actorLoa,
          type: actorType,
          authenticationLevelOfAssurance: actorAcr,
          uuAppKey: actorUuAppKey,
          accountType: actorAccountType
        };
        actorIdentity = new Identity(actorUuIdentity, actorIdentityData);
        // TODO Remove after upgrade to uu_appg01_core-authentication 5.12
        actorIdentity.getAccountType = function () {
          return actorAccountType;
        };
      }
    }
    _this = _super.call(this, {
      id: id,
      authenticationId: authenticationId,
      authenticationTime: authenticationTime,
      authenticationLevelOfAssurance: authenticationLevelOfAssurance,
      identity: identity,
      actorIdentity: actorIdentity,
      clientIdentity: clientIdentity,
      applicationIdentity: applicationIdentity,
      attributes: attributes
    });
    _this._configPrefix = configPrefix;
    _this._serviceName = serviceName;
    _this._oauthClient = oauthClient;
    _this._supportedAcrValues = supportedAcrValues;
    _this._idToken = idToken;
    _this._accessToken = accessToken;
    _this._logger = LoggerFactory.get("uuapp.oidc.Session");
    // TODO Workaround for providers not providing acr value (should be moved to core session)
    if (!_this._authenticated && !_this._authenticationLevelOfAssurance) {
      // Session should return isAuthenticated as true as long as there is some identity other than anonymous
      _this._authenticated = _this._identity && _this._identity.getUuIdentity() && _this._identity.getUuIdentity() !== ANONYMOUS_UUIDENTITY;
    }
    // TODO Remove after upgrade to uu_appg01_core-authentication 5.12
    _this._actorIdentity = actorIdentity;
    return _this;
  }
  _createClass(Session, [{
    key: "getServiceName",
    value: function getServiceName() {
      return this._serviceName;
    }
  }, {
    key: "getServiceUri",
    value: function () {
      var _getServiceUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var service;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              service = CoreAuthenticationService.get(this._serviceName);
              if (!(typeof service.getServiceUri === "function")) {
                _context.next = 7;
                break;
              }
              _context.next = 4;
              return service.getServiceUri();
            case 4:
              _context.t0 = _context.sent;
              _context.next = 8;
              break;
            case 7:
              _context.t0 = null;
            case 8:
              return _context.abrupt("return", _context.t0);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getServiceUri() {
        return _getServiceUri.apply(this, arguments);
      }
      return getServiceUri;
    }()
  }, {
    key: "getProviderUri",
    value: function getProviderUri() {
      var service = CoreAuthenticationService.get(this._serviceName);
      return typeof service.getProviderUri === "function" ? service.getProviderUri() : null;
    }

    /**
     * Returns actor user identity.
     * @returns {Identity} Actor user identity
     */
    // TODO Remove after upgrade to uu_appg01_core-authentication 5.12
  }, {
    key: "getActorIdentity",
    value: function getActorIdentity() {
      return this._actorIdentity;
    }
  }, {
    key: "getCallTokenScope",
    value: function () {
      var _getCallTokenScope = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(uri) {
        var opts,
          scopeMode,
          cfgKey,
          scope,
          gateway,
          uriBuilder,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              opts = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
              scopeMode = opts ? opts.scopeMode : null;
              if (scopeMode == null) {
                cfgKey = "".concat(this._configPrefix, "default_call_token_scope_mode");
                scopeMode = Config.getString(cfgKey) || DEFAULT_SCOPE_MODE;
              }
              if (!(scopeMode === "none")) {
                _context2.next = 5;
                break;
              }
              return _context2.abrupt("return", null);
            case 5:
              if (!(scopeMode === "baseUri" && opts.baseUri)) {
                _context2.next = 10;
                break;
              }
              scope = opts.baseUri.toString().replace(/^\/|\/$/g, "");
              if (!scope.match(/^https?:/i)) {
                gateway = opts.gatewayUri || "https://uuapp.plus4u.net";
                scope = "".concat(gateway.replace(/\/$/, ""), "/").concat(scope);
              }
              _context2.next = 29;
              break;
            case 10:
              _context2.prev = 10;
              uriBuilder = UriBuilder.parse(uri);
              uriBuilder.clearParameters();
              if (!(scopeMode === "useCase")) {
                _context2.next = 17;
                break;
              }
              scope = uriBuilder.toUri().toString();
              _context2.next = 23;
              break;
            case 17:
              if (!(scopeMode === "allUseCases" || scopeMode === "baseUri")) {
                _context2.next = 22;
                break;
              }
              uriBuilder.setUseCase(null);
              scope = uriBuilder.toUri().toString();
              _context2.next = 23;
              break;
            case 22:
              throw new BaseError("Unsupported scope mode: ".concat(scopeMode));
            case 23:
              _context2.next = 29;
              break;
            case 25:
              _context2.prev = 25;
              _context2.t0 = _context2["catch"](10);
              scope = uri.toString().split("?")[0];
              scope = scope.replace(/\/$/, "");
            case 29:
              return _context2.abrupt("return", scope);
            case 30:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[10, 25]]);
      }));
      function getCallTokenScope(_x2) {
        return _getCallTokenScope.apply(this, arguments);
      }
      return getCallTokenScope;
    }()
  }, {
    key: "getCallToken",
    value: function () {
      var _getCallToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(scope) {
        var opts,
          useTokenExchange,
          cfgKey,
          callTokenType,
          _cfgKey,
          excludeAuthType,
          token,
          clientId,
          tokenKey,
          grantedToken,
          tokenToExchange,
          tokenType,
          credentials,
          expiresAt,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              opts = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              useTokenExchange = opts ? opts.useTokenExchange : null;
              if (typeof useTokenExchange !== "boolean") {
                cfgKey = "".concat(this._configPrefix, "use_token_exchange");
                useTokenExchange = Config.hasKey(cfgKey) ? Config.getBoolean(cfgKey) : DEFAULT_USE_TOKEN_EXCHANGE;
              }
              callTokenType = opts ? opts.callTokenType : null;
              if (!callTokenType) {
                _cfgKey = "".concat(this._configPrefix, "call_token_type");
                callTokenType = Config.getString(_cfgKey);
              }
              excludeAuthType = opts ? opts.excludeAuthenticationType : false;
              token = null;
              if (useTokenExchange) {
                _context3.next = 11;
                break;
              }
              if (callTokenType === "idToken") {
                token = this._idToken;
              } else if (callTokenType === "accessToken") {
                token = this._accessToken;
              } else if (!callTokenType) {
                token = this._idToken || this._accessToken;
              }
              _context3.next = 30;
              break;
            case 11:
              _context3.next = 13;
              return ClientCredentialsProvider.getClientId(this._serviceName);
            case 13:
              clientId = _context3.sent;
              if (Array.isArray(scope)) {
                tokenKey = Digest.sha1("".concat(this.getIdentity().getUuIdentity(), ":").concat(this.getAuthenticationId(), ":").concat(clientId, ":").concat(scope.sort().join("|")));
              } else {
                tokenKey = Digest.sha1("".concat(this.getIdentity().getUuIdentity(), ":").concat(this.getAuthenticationId(), ":").concat(clientId, ":").concat(scope));
              }
              _context3.next = 17;
              return this._oauthClient.getToken(tokenKey);
            case 17:
              grantedToken = _context3.sent;
              if (grantedToken) {
                _context3.next = 29;
                break;
              }
              // Try to exchange preferred token type
              if (callTokenType === "idToken") {
                tokenToExchange = this._idToken;
                tokenType = callTokenType;
              } else if (callTokenType === "accessToken") {
                tokenToExchange = this._accessToken;
                tokenType = callTokenType;
              }
              // If preferred token type is not available,
              // try to exchange what we have
              if (!tokenToExchange) {
                if (this._idToken) {
                  tokenToExchange = this._idToken;
                  tokenType = "idToken";
                } else if (this._accessToken) {
                  tokenToExchange = this._accessToken;
                  tokenType = "accessToken";
                }
              }
              _context3.next = 23;
              return ClientCredentialsProvider.getClientCredentials(this._serviceName);
            case 23:
              credentials = _context3.sent;
              _context3.next = 26;
              return this._oauthClient.exchangeToken(tokenToExchange, tokenType, credentials, scope);
            case 26:
              grantedToken = _context3.sent;
              expiresAt = grantedToken.expires_at || Number(new Date() / 1000 + grantedToken.expires_in);
              this._oauthClient.cacheToken(tokenKey, expiresAt, grantedToken);
            case 29:
              if (callTokenType === "idToken") {
                token = grantedToken.id_token;
              } else if (callTokenType === "accessToken") {
                token = grantedToken.access_token;
              } else if (!callTokenType) {
                token = grantedToken.id_token || grantedToken.access_token;
              }
            case 30:
              if (token) {
                _context3.next = 32;
                break;
              }
              throw new BaseError("Call token of type \"".concat(callTokenType || "idToken", "\" is not available."));
            case 32:
              if (!(excludeAuthType === true)) {
                _context3.next = 36;
                break;
              }
              return _context3.abrupt("return", token);
            case 36:
              return _context3.abrupt("return", "Bearer ".concat(token));
            case 37:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getCallToken(_x3) {
        return _getCallToken.apply(this, arguments);
      }
      return getCallToken;
    }()
  }, {
    key: "actAs",
    value: function () {
      var _actAs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(uuIdentity) {
        var scope,
          opts,
          actorTokenType,
          cfgKey,
          actorToken,
          clientId,
          tokenKey,
          grantedToken,
          credentials,
          subjectToken,
          expiresAt,
          claims,
          supportedAcrValues,
          _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              scope = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : null;
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              if (scope != null && typeof scope !== "string" && !Array.isArray(scope)) {
                opts = scope;
                scope = null;
              }
              actorTokenType = opts ? opts.callTokenType : null;
              if (!actorTokenType) {
                cfgKey = "".concat(this._configPrefix, "call_token_type");
                actorTokenType = Config.getString(cfgKey);
              }
              actorToken = null;
              if (actorTokenType === "idToken") {
                actorToken = this._idToken;
              } else if (actorTokenType === "accessToken") {
                actorToken = this._accessToken;
              } else if (!actorTokenType) {
                actorToken = this._idToken || this._accessToken;
              }
              _context4.next = 9;
              return ClientCredentialsProvider.getClientId(this._serviceName);
            case 9:
              clientId = _context4.sent;
              if (Array.isArray(scope)) {
                tokenKey = Digest.sha1("".concat(this.getIdentity().getUuIdentity(), ":").concat(this.getAuthenticationId(), ":").concat(uuIdentity, ":").concat(clientId, ":").concat(scope.sort().join("|")));
              } else {
                tokenKey = Digest.sha1("".concat(this.getIdentity().getUuIdentity(), ":").concat(this.getAuthenticationId(), ":").concat(uuIdentity, ":").concat(clientId, ":").concat(scope));
              }
              _context4.next = 13;
              return this._oauthClient.getToken(tokenKey);
            case 13:
              grantedToken = _context4.sent;
              _context4.next = 16;
              return ClientCredentialsProvider.getClientCredentials(this._serviceName);
            case 16:
              credentials = _context4.sent;
              if (grantedToken) {
                _context4.next = 24;
                break;
              }
              subjectToken = Base64.urlSafeEncode(Json.stringify({
                uuidentity: uuIdentity
              }));
              _context4.next = 21;
              return this._oauthClient.delegateToken(actorToken, actorTokenType, subjectToken, credentials, scope);
            case 21:
              grantedToken = _context4.sent;
              expiresAt = grantedToken.expires_at || Number(new Date() / 1000 + grantedToken.expires_in);
              this._oauthClient.cacheToken(tokenKey, expiresAt, grantedToken);
            case 24:
              _context4.next = 26;
              return this._oauthClient.parseToken(grantedToken.id_token, OAUTH_TOKEN_TYPE_ID_TOKEN, true, credentials);
            case 26:
              claims = _context4.sent;
              _context4.next = 29;
              return this._oauthClient.getSupportedAcrValues();
            case 29:
              supportedAcrValues = _context4.sent;
              return _context4.abrupt("return", new this.constructor(this._serviceName, this._oauthClient, supportedAcrValues, claims, grantedToken.id_token, grantedToken.access_token));
            case 31:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function actAs(_x4) {
        return _actAs.apply(this, arguments);
      }
      return actAs;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this2 = this;
        var credentials;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _get(_getPrototypeOf(Session.prototype), "close", this).call(this);
              _context5.next = 3;
              return ClientCredentialsProvider.getClientCredentials(this._serviceName);
            case 3:
              credentials = _context5.sent;
              if (!(this._idToken || this._accessToken)) {
                _context5.next = 13;
                break;
              }
              _context5.prev = 5;
              _context5.next = 8;
              return this._oauthClient.revokeToken(this._idToken || this._accessToken, credentials);
            case 8:
              _context5.next = 13;
              break;
            case 10:
              _context5.prev = 10;
              _context5.t0 = _context5["catch"](5);
              this._logger.error("Token revocation failed.", _context5.t0);
            case 13:
              this._oauthClient.listTokens(function (tokenKey, grantedToken) {
                if (grantedToken.id_token == _this2._idToken || grantedToken.access_token == _this2._accessToken) {
                  _this2._oauthClient.deleteToken(tokenKey);
                  return false;
                }
              });
              this._idToken = null;
              this._accessToken = null;
            case 16:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[5, 10]]);
      }));
      function close() {
        return _close.apply(this, arguments);
      }
      return close;
    }()
  }], [{
    key: "_createEmptySession",
    value: function _createEmptySession() {
      return new EmptySession();
    }
  }]);
  return Session;
}(CoreSession);
module.exports = Session;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var CoreSession = __webpack_require__(5).Session;
var Identity = __webpack_require__(5).Identity;
var ClientIdentity = __webpack_require__(5).ClientIdentity;
var ApplicationIdentity = __webpack_require__(5).ApplicationIdentity;
var EmptySession = /*#__PURE__*/function (_CoreSession) {
  _inherits(EmptySession, _CoreSession);
  var _super = _createSuper(EmptySession);
  function EmptySession() {
    _classCallCheck(this, EmptySession);
    return _super.call(this, {
      authenticationTime: new Date(Date.now()),
      authenticationLevelOfAssurance: 0,
      identity: new Identity(null),
      clientIdentity: new ClientIdentity(null),
      applicationIdentity: new ApplicationIdentity(null),
      attributes: {}
    });
  }
  _createClass(EmptySession, [{
    key: "getServiceName",
    value: function getServiceName() {
      return null;
    }
  }, {
    key: "getServiceUri",
    value: function () {
      var _getServiceUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", null);
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function getServiceUri() {
        return _getServiceUri.apply(this, arguments);
      }
      return getServiceUri;
    }()
  }, {
    key: "getProviderUri",
    value: function getProviderUri() {
      return null;
    }
  }, {
    key: "getCallToken",
    value: function () {
      var _getCallToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(scope) {
        var opts,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              opts = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
              return _context2.abrupt("return", null);
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function getCallToken(_x) {
        return _getCallToken.apply(this, arguments);
      }
      return getCallToken;
    }()
  }]);
  return EmptySession;
}(CoreSession);
module.exports = EmptySession;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(7),
  Config = _require.Config,
  LruCache = _require.LruCache,
  Base64 = _require.Base64;
var _require2 = __webpack_require__(9),
  AppClient = _require2.AppClient,
  PerflogHandler = _require2.PerflogHandler,
  RemoteErrorHandler = _require2.RemoteErrorHandler,
  TransformParametersHandler = _require2.TransformParametersHandler,
  ApplicationError = _require2.ApplicationError;
var _require3 = __webpack_require__(8),
  LoggerFactory = _require3.LoggerFactory;
var SyncCallNotPossible = __webpack_require__(13);
var Dom = __webpack_require__(28);
var APP_CLIENT_INTERCEPTORS = [PerflogHandler, RemoteErrorHandler, TransformParametersHandler];
var CLIENT_ID_CACHE_SIZE = 256;
var CLIENT_ID_CACHE_TTL = 60 * 60 * 1000;
var CLIENT_ID_CACHE_STORAGE_KEY = "uu_app_oidc_cache_client_id";
var CLIENT_ID_CACHE = new LruCache({
  maxSize: CLIENT_ID_CACHE_SIZE,
  maxAge: CLIENT_ID_CACHE_TTL,
  localStorageKey: CLIENT_ID_CACHE_STORAGE_KEY
});
var LOGGER = LoggerFactory.get("uuapp.oidc.ClientCredentialsProvider");
var CONFIG_PREFIX = "uu_app_oidc_providers_";
var CLIENT_ID_SUFFIX = "_client_id";
var UNREGISTERED_ID_SUFFIX = "_unregistered_client_id";
var UNREGISTERED_CLIENT_ID_PREFIX = "uu-oidc:unregistered-client:";
// TODO Generate default client name based on fingerprint
var DEFAULT_CLIENT_NAME = Math.random().toString(16).substring(2, 10);

/**
 * Browser implementation of client credentials provider allowing of
 * dynamically loading client credentials (client_id) from backend.
 */
var ClientCredentialsProvider = /*#__PURE__*/function () {
  function ClientCredentialsProvider() {
    _classCallCheck(this, ClientCredentialsProvider);
  }
  _createClass(ClientCredentialsProvider, null, [{
    key: "getClientId",
    value:
    /**
     * Returns OIDC client id for given service.
     * @param serviceName Name of registered authentication service.
     * @returns {Object} Client credentials
     */
    function () {
      var _getClientId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(serviceName) {
        var cacheKey, clientId, result, dtoIn, opts;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              cacheKey = Base64.encode("".concat(Dom.appBaseUri, ":").concat(serviceName));
              clientId = CLIENT_ID_CACHE.get(cacheKey) || Config.getString("".concat(CONFIG_PREFIX).concat(serviceName).concat(CLIENT_ID_SUFFIX));
              if (clientId) {
                _context.next = 22;
                break;
              }
              result = null;
              _context.prev = 4;
              dtoIn = {
                serviceName: serviceName
              };
              opts = {
                interceptors: APP_CLIENT_INTERCEPTORS
              };
              _context.next = 9;
              return AppClient.get("".concat(Dom.appBaseUri, "oidc/getClientId"), dtoIn, opts);
            case 9:
              result = _context.sent;
              clientId = result.data.clientId;
              _context.next = 21;
              break;
            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](4);
              if (!(_context.t0 instanceof ApplicationError && _context.t0.status === 404)) {
                _context.next = 20;
                break;
              }
              // We are probably using legacy backend without new endpoint. Provide default credentials of unregistered client.
              LOGGER.warn("Backend does not provide \"oidc/getClientId\" endpoint and custom configuration of clientId is not available. Using unregistered client.");
              clientId = Config.get("".concat(CONFIG_PREFIX).concat(serviceName).concat(UNREGISTERED_ID_SUFFIX)) || "".concat(UNREGISTERED_CLIENT_ID_PREFIX).concat(DEFAULT_CLIENT_NAME);
              _context.next = 21;
              break;
            case 20:
              throw _context.t0;
            case 21:
              CLIENT_ID_CACHE.set(cacheKey, clientId);
            case 22:
              // Static cache is used to allow eviction of standard cache while
              // allow calling of getClientCredentialsSync in case cache was
              // evicted between asynchronous and synchronous invocation.
              this._clientIds[cacheKey] = clientId;
              return _context.abrupt("return", clientId);
            case 24:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[4, 13]]);
      }));
      function getClientId(_x) {
        return _getClientId.apply(this, arguments);
      }
      return getClientId;
    }()
    /**
     * Returns OIDC client id for given service.
     * @param serviceName Name of registered authentication service.
     * @returns {Object} Client credentials
     */
  }, {
    key: "getClientIdSync",
    value: function getClientIdSync(serviceName) {
      var cacheKey = Base64.encode("".concat(Dom.appBaseUri, ":").concat(serviceName));
      var clientId = this._clientIds[cacheKey];
      if (!clientId) {
        throw new SyncCallNotPossible("Asynchronous method getClientId or getClientCredentials must be invoked prior to synchronous invocation");
      }
      return clientId;
    }

    /**
     * Returns OIDC client credentials for given service.
     * @param serviceName Name of registered authentication service.
     * @returns {Object} Client credentials
     */
  }, {
    key: "getClientCredentials",
    value: function () {
      var _getClientCredentials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(serviceName) {
        var clientId;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.getClientId(serviceName);
            case 2:
              clientId = _context2.sent;
              return _context2.abrupt("return", {
                client_id: clientId,
                client_secret: null
              });
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getClientCredentials(_x2) {
        return _getClientCredentials.apply(this, arguments);
      }
      return getClientCredentials;
    }()
    /**
     * Returns OIDC client credentials for given service.
     * @param serviceName Name of registered authentication service.
     * @returns {Object} Client credentials
     */
  }, {
    key: "getClientCredentialsSync",
    value: function getClientCredentialsSync(serviceName) {
      var clientId = this.getClientIdSync(serviceName);
      return {
        client_id: clientId,
        client_secret: null
      };
    }
  }]);
  return ClientCredentialsProvider;
}(); // Static "cache" for sync method
ClientCredentialsProvider._clientIds = {};
module.exports = ClientCredentialsProvider;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

var isBrowser = new Function("try {return this===window;}catch(e){ return false;}")();
var domReadyPromise = isBrowser ? document.readyState === "interactive" || document.readyState === "complete" ? Promise.resolve() : new Promise(function (resolve) {
  document.addEventListener("DOMContentLoaded", resolve, false);
}) : Promise.resolve();
var WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
var BASE_ELEMENT = WINDOW.document.querySelector("base");
var APP_BASE_URI = WINDOW.location.protocol + "//" + WINDOW.location.host + (BASE_ELEMENT && BASE_ELEMENT.getAttribute("data-uu-app-base") || "" || "/");
var CANONICAL_APP_BASE_URI = (new RegExp("uu.app.cbu=([^;]+)").exec(WINDOW.document.cookie) || [])[1];
module.exports = {
  domReady: domReadyPromise,
  window: WINDOW,
  baseElement: BASE_ELEMENT,
  appBaseUri: APP_BASE_URI,
  canonicalAppBaseUri: CANONICAL_APP_BASE_URI,
  toFullAppUrl: function toFullAppUrl(path) {
    // relative & absolute paths are relative to app base
    var a = WINDOW.document.createElement("a");
    a.href = path && path.match(/^[a-z]+:/i) ? path : APP_BASE_URI + (path ? path.replace(/^\/+/, "") : "");
    return a.href.toString(); // browser-normalized URL (removed "../" sequences, ...)
  }
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _excluded = ["error", "error_description", "uu_oidc_error_id", "uu_oidc_error_code"];
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Dom = __webpack_require__(28);
var PopupComponent = __webpack_require__(30);
var IframeComponent = __webpack_require__(32);
var MainWindowComponent = __webpack_require__(33);
var SyncCallNotPossible = __webpack_require__(13);
var InteractionRequired = __webpack_require__(34);
var ClientCredentialsProvider = __webpack_require__(27);
var _require = __webpack_require__(5),
  AuthenticationError = _require.AuthenticationError;
var _require2 = __webpack_require__(7),
  Config = _require2.Config,
  Base64 = _require2.Base64,
  BaseError = _require2.BaseError;
var _require3 = __webpack_require__(8),
  LoggerFactory = _require3.LoggerFactory;
var CONFIG_RESTORE_SESSION_ON_LOAD_GLOBAL = "uu_app_oidc_restore_session_on_load";
var CONFIG_RESTORE_SESSION_ON_LOAD_UVE = "uuAppOidcRestoreSessionOnLoad";
var RESTORE_SESSION_DISABLED = "disabled";
var RESTORE_SESSION_OPTIONAL = "optional";
var CONFIG_REQUESTED_ACR_VALUES = "uu_app_oidc_requested_acr_values";
var CONFIG_MAX_AUTHENTICATION_AGE = "uu_app_oidc_max_authentication_age";
var CONFIG_PREFIX = "uu_app_oidc_providers_";
var LOGIN_POPUP_ENABLED_CONFIG = "_login_popup_enabled";
var LOGIN_POPUP_WIDTH_CONFIG = "_login_popup_width";
var LOGIN_POPUP_HEIGHT_CONFIG = "_login_popup_height";
var CONFIG_POST_LOGOUT_REDIRECT_URI_KEY = "uu_app_oidc_post_logout_redirect_uri";
var LOGOUT_TYPE_CONFIG = "_logout_type";
var LOGOUT_POPUP_WIDTH_CONFIG = "_logout_popup_width";
var LOGOUT_POPUP_HEIGHT_CONFIG = "_logout_popup_height";
var DEFAULT_SCOPE_MODE = "baseUri";
var DEFAULT_POPUP_WIDTH = 655;
var DEFAULT_POPUP_HEIGHT = 875;
var LOGIN_POPUP_DEFAULTS = {
  enabled: {
    oidcg01: true,
    oidcg02: true
  },
  width: {
    oidcg01: 599,
    oidcg02: DEFAULT_POPUP_WIDTH
  },
  height: {
    oidcg01: 600,
    oidcg02: DEFAULT_POPUP_HEIGHT
  }
};
var LOGOUT_DEFAULTS = {
  type: {
    oidcg01: "iframe",
    oidcg02: "iframe"
  },
  popupWidth: {
    oidcg01: 599,
    oidcg02: DEFAULT_POPUP_WIDTH
  },
  popupHeight: {
    oidcg01: 600,
    oidcg02: DEFAULT_POPUP_HEIGHT
  }
};
var AbstractAuthorizationFlow = /*#__PURE__*/function () {
  function AbstractAuthorizationFlow(oauthClient, serviceName, defaultRedirectUri) {
    _classCallCheck(this, AbstractAuthorizationFlow);
    this._oauthClient = oauthClient;
    this._serviceName = serviceName;
    this._defaultRedirectUri = defaultRedirectUri;
    var popupEnabled = Config.getBoolean(CONFIG_PREFIX + serviceName + LOGIN_POPUP_ENABLED_CONFIG);
    if (popupEnabled == null) {
      popupEnabled = LOGIN_POPUP_DEFAULTS.enabled[serviceName];
      this._popupEnabled = popupEnabled == null ? true : popupEnabled;
    } else {
      this._popupEnabled = popupEnabled;
    }
    this._defaultAcrValues = Config.getString(CONFIG_REQUESTED_ACR_VALUES, false);
    this._defaultMaxAge = Config.getNumber(CONFIG_MAX_AUTHENTICATION_AGE, false);
    this._logger = LoggerFactory.get("uuapp.oidc.internal." + serviceName + "." + this.constructor.name);
    this._checkSessionIframe = null;
    this._loadCheckSessionIframePromise = null;
    this._runningCheckSessionPromise = null;
    this._runningCheckSessionResolve = null;
  }
  _createClass(AbstractAuthorizationFlow, [{
    key: "getResponseType",
    value: function getResponseType() {
      throw new Error("AbstractFlow.getResponseType must be implemented on child class.");
    }
  }, {
    key: "createAuthState",
    value: function createAuthState() {
      var authCtx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var usePopup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var state = {
        r: Math.random().toString(32).substr(2),
        // Remember URI of UVE we are leaving (needed in case callback is done in main window - we have to redirect)
        appUri: location.pathname + location.search + (location.hash.length > 1 ? location.hash : ""),
        authCtx: authCtx,
        usePopup: usePopup
      };
      return state;
    }
  }, {
    key: "restoreSession",
    value: function restoreSession(options) {
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this.authenticate(options, scope);
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      var _this = this;
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var uiComponent;
      var resultPromise = new Promise( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {
          var _ref2, acrValues, maxAge, prompt, language, usePopup, authenticationContext, loginHint, noIframe, authUri, clientId, nonce, state, authFinalUri, LoginVisualComponent, requestPromise, authResponse;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _ref2 = options || {}, acrValues = _ref2.acrValues, maxAge = _ref2.maxAge, prompt = _ref2.prompt, language = _ref2.language, usePopup = _ref2.usePopup, authenticationContext = _ref2.authenticationContext, loginHint = _ref2.loginHint, noIframe = _ref2.noIframe;
                if (acrValues == null) acrValues = _this._defaultAcrValues;
                if (maxAge == null) maxAge = _this._defaultMaxAge;
                if (usePopup == null) usePopup = true; // use login popup by default...
                usePopup = usePopup && _this._popupEnabled; // ...unless globally disabled

                // NOTE Using synchronous variant (when prompt != "none") because typically this call is made after
                // clicking a button and we're going to show a popup window. Browsers will block the popup window unless
                // we open it within click event's lifetime or within single Promise (but not Promise chain because
                // that doesn't work on iPhones / Chrome). The sync variant works only if there already has been
                // async variant call, but that's sufficient for us, because we perform session initialization
                // with prompt == "none" (async) during this library's initialization.
                if (!(prompt === "none")) {
                  _context.next = 15;
                  break;
                }
                _context.next = 9;
                return ClientCredentialsProvider.getClientId(_this._serviceName);
              case 9:
                clientId = _context.sent;
                _context.next = 12;
                return _this._oauthClient.getAuthorizationUri(_this.getResponseType(), _this._defaultRedirectUri, clientId, acrValues, scope);
              case 12:
                authUri = _context.sent;
                _context.next = 31;
                break;
              case 15:
                _context.prev = 15;
                clientId = ClientCredentialsProvider.getClientIdSync(_this._serviceName);
                _context.next = 23;
                break;
              case 19:
                _context.prev = 19;
                _context.t0 = _context["catch"](15);
                if (_context.t0 instanceof SyncCallNotPossible) {
                  _this._logger.debug("Trying to reload client id on background.");
                  ClientCredentialsProvider.getClientId(_this._serviceName);
                }
                throw new BaseError("Unable to get client credentials for service ".concat(_this._serviceName, ": ").concat(_context.t0.message), _context.t0);
              case 23:
                _context.prev = 23;
                authUri = _this._oauthClient.getAuthorizationUriSync(_this.getResponseType(), _this._defaultRedirectUri, clientId, acrValues, scope);
                _context.next = 31;
                break;
              case 27:
                _context.prev = 27;
                _context.t1 = _context["catch"](23);
                if (_context.t1 instanceof SyncCallNotPossible) {
                  _this._logger.debug("Trying to reload service metadata on background.");
                  _this._oauthClient.getMetadata();
                }
                throw new BaseError("Unable to get metadata of service ".concat(_this._serviceName, ": ").concat(_context.t1.message), _context.t1);
              case 31:
                nonce = Math.random().toString(32).substr(2);
                state = Base64.urlSafeEncode(JSON.stringify(_this.createAuthState(authenticationContext, usePopup)));
                authFinalUri = _this._addUriParams(authUri, {
                  max_age: maxAge,
                  login_hint: loginHint,
                  prompt: prompt,
                  state: state,
                  nonce: nonce,
                  language: language
                });
                LoginVisualComponent = prompt !== "none" || noIframe ? usePopup ? PopupComponent : MainWindowComponent : IframeComponent;
                _this._logger.debug("Invoking authorization request: ".concat(authFinalUri));
                requestPromise = _this.sendRequest(authFinalUri, LoginVisualComponent);
                if (resultPromise) resultPromise.uiComponent = requestPromise.uiComponent;else uiComponent = requestPromise.uiComponent;
                _context.next = 40;
                return requestPromise;
              case 40:
                authResponse = _context.sent;
                resolve({
                  authResponse: authResponse,
                  state: state,
                  nonce: nonce,
                  scope: scope,
                  acrValues: acrValues,
                  maxAge: maxAge,
                  clientId: clientId
                });
                _context.next = 47;
                break;
              case 44:
                _context.prev = 44;
                _context.t2 = _context["catch"](0);
                reject(_context.t2);
              case 47:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[0, 44], [15, 19], [23, 27]]);
        }));
        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
      if (uiComponent) resultPromise.uiComponent = uiComponent;
      return resultPromise;
    }
  }, {
    key: "getAuthResponseFromCallback",
    value: function getAuthResponseFromCallback(loginCallbackResult) {
      throw new Error("AbstractFlow.getAuthResponseFromCallback must be implemented on child class.");
    }
  }, {
    key: "isCheckSessionSupported",
    value: function () {
      var _isCheckSessionSupported = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (this._loadCheckSessionIframePromise == null) {
                this._loadCheckSessionIframePromise = this._loadCheckSessionIframe();
              }
              _context2.next = 3;
              return this._loadCheckSessionIframePromise;
            case 3:
              return _context2.abrupt("return", !!this._checkSessionIframe);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function isCheckSessionSupported() {
        return _isCheckSessionSupported.apply(this, arguments);
      }
      return isCheckSessionSupported;
    }()
  }, {
    key: "checkSession",
    value: function checkSession(query) {
      var _this2 = this;
      if (this._runningCheckSessionPromise) {
        return this._runningCheckSessionPromise;
      } else {
        var resultResolve = null;
        var resultPromise = new Promise( /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  resultResolve = resolve;
                  _context3.next = 3;
                  return _this2.isCheckSessionSupported();
                case 3:
                  if (_context3.sent) {
                    _context3.next = 7;
                    break;
                  }
                  _this2._runningCheckSessionResolve = null;
                  _this2._runningCheckSessionPromise = null;
                  return _context3.abrupt("return", reject(new BaseError("Check session is not supported.")));
                case 7:
                  _this2._logger.debug("Querying session state change from check session iframe. Query: ".concat(query));
                  _this2._checkSessionIframe.contentWindow.postMessage(query, _this2._iframeTrustedOrigin);
                case 9:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          return function (_x3, _x4) {
            return _ref3.apply(this, arguments);
          };
        }());
        this._runningCheckSessionResolve = resultResolve;
        this._runningCheckSessionPromise = resultPromise;
        return resultPromise;
      }
    }
  }, {
    key: "refreshSession",
    value: function refreshSession(options) {
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this.authenticate(options, scope);
    }
  }, {
    key: "getCallToken",
    value: function () {
      var _getCallToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options) {
        var scope,
          _yield$this$authentic,
          idToken,
          accessToken,
          claims,
          expireAt,
          _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              scope = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : null;
              _context4.next = 3;
              return this.authenticate(options, scope);
            case 3:
              _yield$this$authentic = _context4.sent;
              idToken = _yield$this$authentic.idToken;
              accessToken = _yield$this$authentic.accessToken;
              claims = _yield$this$authentic.claims;
              expireAt = claims.exp * 1000;
              return _context4.abrupt("return", {
                idToken: idToken,
                accessToken: accessToken,
                expireAt: expireAt
              });
            case 9:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getCallToken(_x5) {
        return _getCallToken.apply(this, arguments);
      }
      return getCallToken;
    }()
  }, {
    key: "getEndSessionUri",
    value: function getEndSessionUri() {
      throw new Error("AbstractFlow.getEndSessionUri must be implemented on child class.");
    }
  }, {
    key: "isEndSessionIdTokenHintRequired",
    value: function isEndSessionIdTokenHintRequired() {
      return true;
    }
  }, {
    key: "endSession",
    value: function endSession(session) {
      var _this3 = this;
      var resultPromise = new Promise( /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(resolve, reject) {
          var endSessionUri, idTokenHint, useIdTokenHint, cfgKey, scopeMode, opts, postLogoutRedirectUri, logoutType, width, height, LogoutVisualComponent;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                endSessionUri = _this3.getEndSessionUri();
                idTokenHint = null;
                useIdTokenHint = Config.getBoolean(CONFIG_PREFIX + session.getServiceName() + "_logout_token_hint_enabled");
                useIdTokenHint = useIdTokenHint != null ? useIdTokenHint : true;
                if (!(useIdTokenHint && _this3.isEndSessionIdTokenHintRequired())) {
                  _context5.next = 23;
                  break;
                }
                cfgKey = "".concat(CONFIG_PREFIX).concat(session.getServiceName(), "_default_call_token_scope_mode");
                scopeMode = Config.getString(cfgKey) || DEFAULT_SCOPE_MODE;
                if (!(scopeMode === "none")) {
                  _context5.next = 11;
                  break;
                }
                idTokenHint = session._idToken;
                _context5.next = 23;
                break;
              case 11:
                _context5.prev = 11;
                _this3._logger.debug("Obtaining token to be used as id_token_hint for end session request.");
                opts = {
                  callTokenType: "idToken",
                  excludeAuthenticationType: true
                };
                _context5.next = 16;
                return session.getCallToken(endSessionUri, opts);
              case 16:
                idTokenHint = _context5.sent;
                _context5.next = 23;
                break;
              case 19:
                _context5.prev = 19;
                _context5.t0 = _context5["catch"](11);
                _this3._logger.warn("Unable to provide id_token_hint for end session request, using standard token.", _context5.t0);
                idTokenHint = session._idToken;
              case 23:
                // Parameter "post_logout_redirect_uri" can be sent only if token hint is given (without
                // token hint, redirect uri cannot be verified), or in case it is not required.
                if (idTokenHint || !_this3.isEndSessionIdTokenHintRequired()) {
                  postLogoutRedirectUri = Config.getString(CONFIG_POST_LOGOUT_REDIRECT_URI_KEY);
                  if (postLogoutRedirectUri) {
                    postLogoutRedirectUri = Dom.toFullAppUrl(postLogoutRedirectUri);
                  } else {
                    postLogoutRedirectUri = _this3._defaultRedirectUri;
                  }
                  endSessionUri += endSessionUri.includes("?") ? "&" : "?";
                  endSessionUri += "post_logout_redirect_uri=" + encodeURIComponent(postLogoutRedirectUri);
                  if (idTokenHint) {
                    endSessionUri += "&id_token_hint=" + encodeURIComponent(idTokenHint);
                  }
                }
                logoutType = Config.getString(CONFIG_PREFIX + _this3._serviceName + LOGOUT_TYPE_CONFIG) || LOGOUT_DEFAULTS.type[_this3._serviceName];
                width = Config.getNumber(CONFIG_PREFIX + _this3._serviceName + LOGOUT_POPUP_WIDTH_CONFIG) || LOGOUT_DEFAULTS.popupWidth[_this3._serviceName] || DEFAULT_POPUP_WIDTH;
                height = Config.getNumber(CONFIG_PREFIX + _this3._serviceName + LOGOUT_POPUP_HEIGHT_CONFIG) || LOGOUT_DEFAULTS.popupHeight[_this3._serviceName] || DEFAULT_POPUP_HEIGHT;
                LogoutVisualComponent = logoutType === "main" ? MainWindowComponent : logoutType === "popup" ? PopupComponent : IframeComponent;
                _this3._logger.debug("Invoking end session request: ".concat(endSessionUri));
                new LogoutVisualComponent({
                  width: width,
                  height: height,
                  url: endSessionUri,
                  onResult: function onResult(result) {
                    if (result instanceof Error) {
                      reject(result);
                    } else {
                      resolve();
                    }
                  }
                }).render();
              case 30:
              case "end":
                return _context5.stop();
            }
          }, _callee5, null, [[11, 19]]);
        }));
        return function (_x6, _x7) {
          return _ref4.apply(this, arguments);
        };
      }());
      return resultPromise;
    }
  }, {
    key: "sendRequest",
    value: function sendRequest(uri) {
      var _this4 = this;
      var LoginVisualComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IframeComponent;
      var getAuthResponseFromCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getAuthResponseFromCallback.bind(this);
      var uiComponent;
      var result = new Promise(function (resolve, reject) {
        var width = Config.getNumber(CONFIG_PREFIX + _this4._serviceName + LOGIN_POPUP_WIDTH_CONFIG) || LOGIN_POPUP_DEFAULTS.width[_this4._serviceName] || DEFAULT_POPUP_WIDTH;
        var height = Config.getNumber(CONFIG_PREFIX + _this4._serviceName + LOGIN_POPUP_HEIGHT_CONFIG) || LOGIN_POPUP_DEFAULTS.height[_this4._serviceName] || DEFAULT_POPUP_HEIGHT;
        uiComponent = new LoginVisualComponent({
          width: width,
          height: height,
          url: uri,
          onResult: function onResult(aLoginResult) {
            if (aLoginResult instanceof Error) return reject(aLoginResult);
            if (aLoginResult === false) return reject(new AuthenticationError("User refused to log in."));
            if (aLoginResult === PopupComponent.ERROR_POPUP_BLOCKED) return reject(new AuthenticationError("Login failed due to popup blocking."));
            var authResponse = getAuthResponseFromCallback(aLoginResult);

            // resolve the promise successfully with the token (iff there's no "error" field)
            if (authResponse.error) {
              var error = authResponse.error,
                error_description = authResponse.error_description,
                uu_oidc_error_id = authResponse.uu_oidc_error_id,
                uu_oidc_error_code = authResponse.uu_oidc_error_code,
                rest = _objectWithoutProperties(authResponse, _excluded);
              var errorCode = uu_oidc_error_code || error;
              var errorMessage = error_description || "Authentication error: " + error;
              var authnError;
              if (errorCode && errorCode.match(/(interaction|login|account_selection|consent)_required/i) || errorMessage && errorMessage.match(/interaction required/i)) {
                authnError = new InteractionRequired(errorMessage);
              } else {
                authnError = new AuthenticationError(errorMessage);
              }
              authnError.code = errorCode;
              if (uu_oidc_error_id) {
                authnError.id = uu_oidc_error_id;
              }
              Object.assign(authnError, rest);
              reject(authnError);
            } else {
              resolve(authResponse);
            }
          }
        });
        uiComponent.render();
      });
      result.uiComponent = uiComponent;
      return result;
    }
  }, {
    key: "_loadCheckSessionIframe",
    value: function () {
      var _loadCheckSessionIframe2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var _this5 = this;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              return _context7.abrupt("return", new Promise( /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(resolve) {
                  var iframeUrl, iframe;
                  return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return Dom.domReady;
                      case 2:
                        _context6.next = 4;
                        return _this5._oauthClient.getCheckSessionIframeUri();
                      case 4:
                        iframeUrl = _context6.sent;
                        if (!iframeUrl) {
                          _this5._logger.warn("The OpenID Connect server ".concat(_this5._oauthClient.getServiceUri(), " doesn't support check_session_iframe endpoint."));
                          resolve();
                        } else {
                          _this5._logger.debug("Creating iframe with check_session_iframe endpoint URL: ".concat(iframeUrl));
                          iframe = document.createElement("iframe");
                          iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
                          iframe.tabIndex = "-1";
                          iframe.onload = function () {
                            _this5._iframeTrustedOrigin = iframeUrl.match(/^(https?:\/\/[^\/]+).*$/)[1] || null;
                            _this5._checkSessionIframe = iframe;
                            // add message handler for processing messages from the iframe
                            window.addEventListener("message", _this5._onMessage.bind(_this5));
                            resolve();
                          };
                          iframe.src = iframeUrl;
                          document.body.appendChild(iframe);
                        }
                      case 6:
                      case "end":
                        return _context6.stop();
                    }
                  }, _callee6);
                }));
                return function (_x8) {
                  return _ref5.apply(this, arguments);
                };
              }()));
            case 1:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));
      function _loadCheckSessionIframe() {
        return _loadCheckSessionIframe2.apply(this, arguments);
      }
      return _loadCheckSessionIframe;
    }()
  }, {
    key: "_onMessage",
    value: function _onMessage(message) {
      this._logger.debug("Received message from ".concat(message.origin, ": ").concat(message.data));
      if (!this._checkSessionIframe || message.source !== this._checkSessionIframe.contentWindow || message.origin !== this._iframeTrustedOrigin) {
        this._logger.debug("Message \"".concat(message.data, "\" from ").concat(message.origin, " is not from check session iframe, ignoring."));
      } else {
        this._logger.debug("Propagating session state \"".concat(message.data, "\" to listeners."));
        if (this._runningCheckSessionResolve) {
          this._runningCheckSessionResolve(message.data);
        }
        this._runningCheckSessionResolve = null;
        this._runningCheckSessionPromise = null;
      }
    }
  }, {
    key: "_addUriParams",
    value: function _addUriParams(uri, params) {
      var paramParts = [];
      for (var k in params) {
        var v = params[k];
        if (v == null) continue;
        paramParts.push(encodeURIComponent(k) + "=" + encodeURIComponent(v + ""));
      }
      return uri + "&" + paramParts.join("&");
    }
  }], [{
    key: "getRestoreSessionOnLoad",
    value: function getRestoreSessionOnLoad() {
      var metaTag = document.querySelector("meta[".concat(CONFIG_RESTORE_SESSION_ON_LOAD_UVE, "]"));
      var restoreOnLoad = metaTag ? metaTag.attributes[CONFIG_RESTORE_SESSION_ON_LOAD_UVE].value : null;
      if (!restoreOnLoad) {
        restoreOnLoad = Config.getString(CONFIG_RESTORE_SESSION_ON_LOAD_GLOBAL);
        if (restoreOnLoad == null || restoreOnLoad === "true") {
          restoreOnLoad = RESTORE_SESSION_OPTIONAL;
        } else if (restoreOnLoad === "false") {
          restoreOnLoad = RESTORE_SESSION_DISABLED;
        }
      }
      return restoreOnLoad;
    }
  }]);
  return AbstractAuthorizationFlow;
}();
module.exports = AbstractAuthorizationFlow;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var CallbackHandler = __webpack_require__(31);
var DEFAULT_POPUP_WIDTH = 599;
var DEFAULT_POPUP_HEIGHT = 600;

/**
 * Default visual component for presenting login/logout prompt to the user. It displays the
 * URL in a popup window and waits until the user logs in / closes the window. After that
 * initAttrs.onResult(authResultUrl) is called as callback.
 *
 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
 * @param initAttrs.onResult The callback to call after login finishes. If the login finished
 *   by user closing the window (e.g. via close button), the passed value is <code>false</code>.
 *   Otherwise it's the URL that was deemed as final response from OpenID Connect server (which
 *   contains the authentication response in fragment).
 */
var PopupComponent = function PopupComponent(initAttrs) {
  var attrs = Object.assign({}, initAttrs);
  var state = {
    loginWindow: null,
    closeCheckInterval: null
  };

  // add self to the list of opened loginWindows
  CallbackHandler.registerForCallback(this, state);
  this.finalize = function (result) {
    // cleanup & do the callback
    this.finalize = function () {};
    this.destroy();
    if (attrs.onResult) attrs.onResult(result);
  }.bind(this);
  var closeCheck = function () {
    if (!state.loginWindow || !state.loginWindow.closed) return;
    this.finalize(false); // closed without calling callback (i.e. refused to login or some other reason) => notify with special value "false"
  }.bind(this);
  this.render = function () {
    var _this = this;
    // open popup window centered on screen and wait until global callback is called (or window is closed in other way)
    if (!state.loginWindow) {
      var rect = {
        width: attrs.width || DEFAULT_POPUP_WIDTH,
        height: attrs.height || DEFAULT_POPUP_HEIGHT
      };
      rect.left = (screen.availWidth - rect.width) / 2 + (screen.availLeft || 0);
      rect.top = (screen.availHeight - rect.height) / 2 + (screen.availTop || 0);
      state.loginWindow = window.open(attrs.url, "_blank", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=".concat(rect.width, ",height=").concat(rect.height, ",top=").concat(rect.top, ",left=").concat(rect.left));
      if (!state.loginWindow) {
        // popup blocked or not yet allowed (which means we won't be able to detect window closing) => handle as if user refused to log in
        Promise.resolve().then(function () {
          return _this.finalize(PopupComponent.ERROR_POPUP_BLOCKED);
        }); // finalize in async way
      } else {
        state.closeCheckInterval = setInterval(closeCheck.bind(this), 200);
      }
    }
  };
  this.focus = function () {
    if (state.loginWindow) state.loginWindow.focus();
  };
  this.destroy = function () {
    if (state.loginWindow && !state.loginWindow.closed) state.loginWindow.close();
    if (state.closeCheckInterval) clearInterval(state.closeCheckInterval);
    this.destroy = function () {};
    CallbackHandler.unregisterForCallback(this);
  };
};
PopupComponent.ERROR_POPUP_BLOCKED = "POPUP_BLOCKED";
module.exports = PopupComponent;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
// login callback handling
var VC_CALLBACK_FN_NAME = "uuOidcCallbackFn"; // !!! Must be in sync with the one in callbacks/oidc-callback.html.

// make sure that callback works correctly even if multiple invocations using visual component below were
// done (e.g. user clicked 2 different buttons for command invocations which each opened a login popup
// and are now displayed both)
if (typeof window != "undefined" && !window[VC_CALLBACK_FN_NAME]) {
  window[VC_CALLBACK_FN_NAME] = function (aLoginResult, aSourceWindow, aAuthCtx) {
    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
    // received callback from a popup => find out which component is using the source window and notify it
    for (var i = 0; i < loginWindows.length; ++i) {
      var p = loginWindows[i];
      if (p.state.loginWindow == aSourceWindow) {
        if (aAuthCtx) {
          sessionStorage.setItem("uu_app_oidc_auth_ctx", _typeof(aAuthCtx) === "object" ? JSON.stringify(aAuthCtx) : aAuthCtx);
        }
        p.component.finalize(aLoginResult);
        return;
      }
    }
    console.warn("[" + new Date().toISOString() + "]  WARN uuapp.oidc.CallbackHandler: Received unexpected callback from window", aSourceWindow, "Passed result was:", aLoginResult, "Ignoring the callback.");
  };
  window[VC_CALLBACK_FN_NAME].loginWindows = [];
}
module.exports = {
  registerForCallback: function registerForCallback(component, state) {
    window[VC_CALLBACK_FN_NAME].loginWindows.push({
      component: component,
      state: state
    });
  },
  unregisterForCallback: function unregisterForCallback(component) {
    var loginWindows = window[VC_CALLBACK_FN_NAME].loginWindows;
    for (var i = 0; i < loginWindows.length; ++i) {
      // remove self from opened loginWindows
      if (loginWindows[i].component === component) {
        loginWindows.splice(i, 1);
        break;
      }
    }
  }
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var CallbackHandler = __webpack_require__(31);

/**
 * Visual component for attempting user login/logout on a background in an iframe. Usable only for prompt="none" cases.
 * After login/logout initAttrs.onResult(authResultUrl) is called as callback. In case of an error, an error instance
 * is passed to the callback.
 *
 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
 * @param initAttrs.onResult The callback to call after login/logout finishes.
 * @param initAttrs.timeout Seconds to wait after which consider the attempt unsuccessful, resulting in an error result.
 */
var IframeComponent = function IframeComponent(initAttrs) {
  var attrs = Object.assign({}, initAttrs);
  var state = {
    iframe: null
  };
  Object.defineProperty(state, "loginWindow", {
    get: function get() {
      try {
        // needs try-catch depending on which phase we're being asked (might be during redirect, ..., which can be cross-domain)
        return state.iframe != null ? state.iframe.contentWindow : null;
      } catch (e) {
        // ignore
      }
      return null;
    }
  });

  // add self to the list of openend loginWindows
  CallbackHandler.registerForCallback(this, state);

  // finalization callback (for this component instance) called after login from redirect_uri page
  this.finalize = function (aLoginResult) {
    // cleanup & do the callback
    this.finalize = function () {};
    this.destroy();
    if (attrs.onResult) attrs.onResult(aLoginResult);
  }.bind(this);
  this.render = function () {
    var _this = this;
    if (!state.iframe) {
      var callbackError = new Error("Server did not provide expected callback HTML page. Check if requested URL " + attrs.url + " contains proper redirect parameter. If so, look also into network console for possible callback response error.");
      state.iframe = document.createElement("iframe");
      state.iframe.style.cssText = "position: absolute;top: -300px; left: -300px; width: 200px; height: 200px; opacity: 0;";
      state.iframe.src = attrs.url;
      state.iframe.onload = function () {
        return _this.finalize(callbackError);
      }; // proper callback page will perform callback prior to onload event
      state.iframe.onerror = function () {
        return _this.finalize(callbackError);
      };
      document.body.appendChild(state.iframe);
      if (attrs.timeout) this._timeout = setTimeout(function () {
        _this.finalize(new Error("OIDC iframe didn't receive callback within " + attrs.timeout + "s."));
      }, attrs.timeout * 1000);
    }
  };
  this.destroy = function () {
    if (state.iframe && state.iframe.parentNode) state.iframe.parentNode.removeChild(state.iframe);
    this.destroy = function () {};
    if (this._timeout) clearTimeout(this._timeout);
    CallbackHandler.unregisterForCallback(this);
  };
};
module.exports = IframeComponent;

/***/ }),
/* 33 */
/***/ (function(module, exports) {

/**
 * Visual component for presenting login/logout prompt to the user in main application window.
 *
 * @param initAttrs.url The URL to be called on OpenID Connect Server for user authentication.
 * @param initAttrs.onResult The callback to call in case login attempt was aborted.
 */
var MainWindowComponent = function MainWindowComponent(initAttrs) {
  var attrs = Object.assign({}, initAttrs);
  this.render = function () {
    location.href = attrs.url;
    setTimeout(function () {
      attrs.onResult(new Error("Login aborted"));
    }, 10000);
  };
};
module.exports = MainWindowComponent;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var _require = __webpack_require__(5),
  AuthenticationError = _require.AuthenticationError;

/**
 * Error raised in case authentication cannot be finished without user interaction.
 */
var InteractionRequired = /*#__PURE__*/function (_AuthenticationError) {
  _inherits(InteractionRequired, _AuthenticationError);
  var _super = _createSuper(InteractionRequired);
  function InteractionRequired() {
    _classCallCheck(this, InteractionRequired);
    return _super.apply(this, arguments);
  }
  return _createClass(InteractionRequired);
}(AuthenticationError);
module.exports = InteractionRequired;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var _require = __webpack_require__(5),
  AuthenticationError = _require.AuthenticationError;
var AbstractAuthorizationFlow = __webpack_require__(29);
var RESPONSE_TYPE = "id_token token";
var RESTORE_SESSION_FORCED = "forced";
var ImplicitFlow = /*#__PURE__*/function (_AbstractAuthorizatio) {
  _inherits(ImplicitFlow, _AbstractAuthorizatio);
  var _super = _createSuper(ImplicitFlow);
  function ImplicitFlow(oauthClient, serviceName, redirectUri, appBaseUri) {
    var _this;
    _classCallCheck(this, ImplicitFlow);
    _this = _super.call(this, oauthClient, serviceName, redirectUri);
    _this._oauthClient = oauthClient;
    _this._serviceName = serviceName;
    return _this;
  }
  _createClass(ImplicitFlow, [{
    key: "getResponseType",
    value: function getResponseType() {
      return RESPONSE_TYPE;
    }
  }, {
    key: "restoreSession",
    value: function () {
      var _restoreSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        var scope,
          isAuthCallback,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              scope = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              isAuthCallback = sessionStorage.getItem("uu_app_oidc_auth_cb");
              sessionStorage.removeItem("uu_app_oidc_auth_cb");
              options = _objectSpread({
                prompt: "none"
              }, options);
              if (!(!isAuthCallback && AbstractAuthorizationFlow.getRestoreSessionOnLoad() === RESTORE_SESSION_FORCED)) {
                _context.next = 10;
                break;
              }
              _context.next = 7;
              return this._oauthClient.getMetadata();
            case 7:
              delete options.prompt;
              options.usePopup = false;
              // Store current referrer to provide it after redirect
              sessionStorage.setItem("uu_app_oidc_auth_referrer", document.referrer);
            case 10:
              return _context.abrupt("return", _get(_getPrototypeOf(ImplicitFlow.prototype), "restoreSession", this).call(this, options, scope));
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function restoreSession(_x) {
        return _restoreSession.apply(this, arguments);
      }
      return restoreSession;
    }()
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      var _this2 = this;
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var promise = _get(_getPrototypeOf(ImplicitFlow.prototype), "authenticate", this).call(this, options, scope);
      var result = promise.then(function (_ref) {
        var authResponse = _ref.authResponse,
          state = _ref.state,
          nonce = _ref.nonce,
          scope = _ref.scope,
          acrValues = _ref.acrValues,
          maxAge = _ref.maxAge,
          clientId = _ref.clientId;
        return _this2._processAuthResponse(authResponse, state, nonce, scope, acrValues, maxAge, clientId);
      });
      result.uiComponent = promise.uiComponent;
      return result;
    }

    /**
     * @param {*} aLoginCallbackResult
     * @returns OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
     */
  }, {
    key: "getAuthResponseFromCallback",
    value: function getAuthResponseFromCallback(aLoginCallbackResult) {
      // extract login token
      // example of successful aLoginCallbackResult: "...#access_token=UUOIDCAT-27a13a6e626a40c49e036cbab55f3e27&id_token=eyJ0eXAiOi...&token_type=Bearer&expires_in=7200&scope=openid"
      // example of error aLoginCallbackResult:      "...#error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
      var authResponse = {};
      aLoginCallbackResult.replace(/^[^#]*#?/, "").split(/&/).forEach(function (it) {
        var eqlIdx = it.indexOf("=");
        var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
        var value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx + 1)).replace(/\+/g, " "));
        authResponse[key] = value;
      });
      return authResponse;
    }
  }, {
    key: "refreshSession",
    value: function refreshSession(options) {
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      options = _objectSpread({
        prompt: "none",
        usePopup: false
      }, options);
      return _get(_getPrototypeOf(ImplicitFlow.prototype), "refreshSession", this).call(this, options, scope);
    }
  }, {
    key: "getEndSessionUri",
    value: function getEndSessionUri() {
      return this._oauthClient.getEndSessionUriSync();
    }

    // ======================== Protected methods ================================
  }, {
    key: "_processAuthResponse",
    value: function () {
      var _processAuthResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authResponse, state, nonce, scope, acrValues, maxAge, clientId) {
        var authResponseTime, claims, id_token, access_token, session_expires_in, session_state, globalSessionExpiresAt, authenticationContext;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              // NOTE Used from Os8Flow too.
              authResponseTime = Date.now();
              _context2.next = 3;
              return this._validateAuthResponse(authResponse, state, nonce);
            case 3:
              claims = _context2.sent;
              id_token = authResponse.id_token, access_token = authResponse.access_token, session_expires_in = authResponse.session_expires_in, session_state = authResponse.session_state;
              globalSessionExpiresAt = session_expires_in ? authResponseTime + 1000 * session_expires_in : null;
              sessionStorage.removeItem("uu_app_oidc_auth_cb");
              authenticationContext = sessionStorage.getItem("uu_app_oidc_auth_ctx");
              if (authenticationContext) {
                authenticationContext = JSON.parse(authenticationContext);
                sessionStorage.removeItem("uu_app_oidc_auth_ctx");
              }
              return _context2.abrupt("return", {
                claims: claims,
                idToken: id_token,
                accessToken: access_token,
                authenticationContext: authenticationContext,
                globalSessionExpiresAt: globalSessionExpiresAt,
                globalSessionState: session_state,
                clientId: clientId,
                scope: scope,
                acrValues: acrValues,
                maxAge: maxAge
              });
            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _processAuthResponse(_x2, _x3, _x4, _x5, _x6, _x7, _x8) {
        return _processAuthResponse2.apply(this, arguments);
      }
      return _processAuthResponse;
    }() // ======================== Private methods ================================
  }, {
    key: "_validateAuthResponse",
    value: function () {
      var _validateAuthResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(authResponse, state, nonce) {
        var claims;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(state && authResponse.state !== state)) {
                _context3.next = 2;
                break;
              }
              throw new AuthenticationError("Invalid 'state' in received authorization response. Expected " + state + " but got " + authResponse.state + ". Response: " + JSON.stringify(authResponse));
            case 2:
              if (!this._isAuthResponseExpired(authResponse)) {
                _context3.next = 4;
                break;
              }
              throw new AuthenticationError("Token expired " + JSON.stringify(authResponse));
            case 4:
              _context3.next = 6;
              return this._oauthClient.parseToken(authResponse.id_token, "idToken");
            case 6:
              claims = _context3.sent;
              if (!(nonce && claims.nonce !== nonce)) {
                _context3.next = 9;
                break;
              }
              throw new AuthenticationError("Invalid nonce in ID token claims. Expected " + nonce + " but got " + claims.nonce);
            case 9:
              return _context3.abrupt("return", claims);
            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _validateAuthResponse(_x9, _x10, _x11) {
        return _validateAuthResponse2.apply(this, arguments);
      }
      return _validateAuthResponse;
    }()
  }, {
    key: "_isAuthResponseExpired",
    value: function _isAuthResponseExpired(authResponse) {
      var now = new Date().getTime() / 1000;
      var leeway = 60;
      var expired = false;
      if (!authResponse.issued_at) authResponse.issued_at = now;
      if (authResponse.expires_at) expired = expired || authResponse.expires_at < now - leeway;
      if (authResponse.expires_in && authResponse.issued_at) expired = expired || Number(authResponse.expires_in) + Number(authResponse.issued_at) < now - leeway;
      return expired;
    }
  }]);
  return ImplicitFlow;
}(AbstractAuthorizationFlow);
module.exports = ImplicitFlow;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var _require = __webpack_require__(5),
  AuthenticationError = _require.AuthenticationError;
var _require2 = __webpack_require__(9),
  AppClient = _require2.AppClient;
var AbstractAuthorizationFlow = __webpack_require__(29);
var ImplicitFlow = __webpack_require__(35);
var RESPONSE_TYPE = "code";
var RESTORE_SESSION_FORCED = "forced";
var WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
var CSRF_COOKIE = new RegExp("uu.app.csrf=([^;]+)");
var CodeFlow = /*#__PURE__*/function (_AbstractAuthorizatio) {
  _inherits(CodeFlow, _AbstractAuthorizatio);
  var _super = _createSuper(CodeFlow);
  function CodeFlow(oauthClient, serviceName, redirectUri, appBaseUri) {
    var _this;
    _classCallCheck(this, CodeFlow);
    _this = _super.call(this, oauthClient, serviceName, redirectUri);
    _this._oauthClient = oauthClient;
    _this._serviceName = serviceName;
    _this._redirectUri = redirectUri;
    _this._appBaseUri = appBaseUri;
    _this._client = new AppClient();
    // Code based flow uses implicit flow to obtain call token for external services
    _this._implicitFlow = new ImplicitFlow(oauthClient, serviceName, redirectUri, appBaseUri);
    return _this;
  }
  _createClass(CodeFlow, [{
    key: "getResponseType",
    value: function getResponseType() {
      return RESPONSE_TYPE;
    }
  }, {
    key: "createAuthState",
    value: function createAuthState() {
      var authCtx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var usePopup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var result = _get(_getPrototypeOf(CodeFlow.prototype), "createAuthState", this).call(this, authCtx, usePopup);
      result.redirectUri = this._redirectUri;
      return result;
    }
  }, {
    key: "restoreSession",
    value: function () {
      var _restoreSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        var scope,
          isAuthCallback,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              scope = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              isAuthCallback = sessionStorage.getItem("uu_app_oidc_auth_cb");
              sessionStorage.removeItem("uu_app_oidc_auth_cb");
              options = _objectSpread({
                prompt: "none"
              }, options);
              if (!(!isAuthCallback && AbstractAuthorizationFlow.getRestoreSessionOnLoad() === RESTORE_SESSION_FORCED)) {
                _context.next = 10;
                break;
              }
              _context.next = 7;
              return this._oauthClient.getMetadata();
            case 7:
              delete options.prompt;
              options.usePopup = false;
              // Store current referrer to provide it after redirect
              sessionStorage.setItem("uu_app_oidc_auth_referrer", document.referrer);
            case 10:
              return _context.abrupt("return", _get(_getPrototypeOf(CodeFlow.prototype), "restoreSession", this).call(this, options, scope));
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function restoreSession(_x) {
        return _restoreSession.apply(this, arguments);
      }
      return restoreSession;
    }()
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      var _this2 = this;
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var promise = _get(_getPrototypeOf(CodeFlow.prototype), "authenticate", this).call(this, options, scope);
      var result = promise.then(function (_ref) {
        var authResponse = _ref.authResponse,
          state = _ref.state,
          nonce = _ref.nonce,
          scope = _ref.scope,
          acrValues = _ref.acrValues,
          maxAge = _ref.maxAge,
          clientId = _ref.clientId;
        return _this2._processAuthResponse(authResponse, state, nonce, scope, acrValues, maxAge, clientId);
      });
      result.uiComponent = promise.uiComponent;
      return result;
    }

    /**
     * @param {*} aLoginCallbackResult
     * @returns OpenID Authentication Response with fields such as id_token, token_type, issued_at, ...
     */
  }, {
    key: "getAuthResponseFromCallback",
    value: function getAuthResponseFromCallback(aLoginCallbackResult) {
      // extract login token
      // example of successful aLoginCallbackResult: "...?code=...&state=...
      // example of error aLoginCallbackResult:      "...?error=server_error&error_description=Interaction+required+to+authenticate+user%2C+but+parameter+%27prompt%3Dnone%27+specified+by+client%2C+so+interaction+is+not+possible.&uu_oidc_error_id=047a06f806d1b13-6f55e2af8c2ff99d&uu_oidc_error_code=UU.OIDC-SERVER%2FE000_UNEXPECTED_ERROR"
      var authResponse = {};
      aLoginCallbackResult.replace(/^[^?#]*[?#]?/, "").replace(/#/, "&").split(/&/).filter(Boolean).forEach(function (it) {
        var eqlIdx = it.indexOf("=");
        var key = decodeURIComponent((eqlIdx == -1 ? it.substr(0) : it.substr(0, eqlIdx)).replace(/\+/g, " "));
        var value = decodeURIComponent((eqlIdx == -1 ? "" : it.substr(eqlIdx + 1)).replace(/\+/g, " "));
        authResponse[key] = value;
      });
      return authResponse;
    }
  }, {
    key: "refreshSession",
    value: function refreshSession(options) {
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      options = _objectSpread({
        prompt: "none",
        usePopup: false
      }, options);
      return _get(_getPrototypeOf(CodeFlow.prototype), "refreshSession", this).call(this, options, scope);
    }
  }, {
    key: "getCallToken",
    value: function getCallToken(options) {
      var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this._implicitFlow.getCallToken(options, scope);
    }
  }, {
    key: "getEndSessionUri",
    value: function getEndSessionUri() {
      var endSessionUri = this._appBaseUri + "oidc/logout";
      var csrfToken = (CSRF_COOKIE.exec(WINDOW.document.cookie) || [])[1];
      if (csrfToken) {
        endSessionUri += "?csrf_token=".concat(encodeURIComponent(csrfToken));
      }
      return endSessionUri;
    }
  }, {
    key: "isEndSessionIdTokenHintRequired",
    value: function isEndSessionIdTokenHintRequired() {
      return false;
    }

    // ======================== Protected methods ================================
  }, {
    key: "_processAuthResponse",
    value: function () {
      var _processAuthResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(authResponse, state, nonce, scope, acrValues, maxAge, clientId) {
        var authResponseTime, claims, session_expires_in, session_state, globalSessionExpiresAt, authenticationContext;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              authResponseTime = Date.now();
              _context2.next = 3;
              return this._validateAuthResponse(authResponse, state, nonce);
            case 3:
              _context2.next = 5;
              return this._client.get(this._appBaseUri + "oidc/introspect", {
                _: Date.now()
              });
            case 5:
              claims = _context2.sent.data;
              delete claims.session_info;
              delete claims.uuAppErrorMap;
              session_expires_in = authResponse.session_expires_in, session_state = authResponse.session_state;
              globalSessionExpiresAt = session_expires_in ? authResponseTime + 1000 * session_expires_in : null;
              sessionStorage.removeItem("uu_app_oidc_auth_cb");
              authenticationContext = sessionStorage.getItem("uu_app_oidc_auth_ctx");
              if (authenticationContext) {
                authenticationContext = JSON.parse(authenticationContext);
                sessionStorage.removeItem("uu_app_oidc_auth_ctx");
              }
              return _context2.abrupt("return", {
                claims: claims,
                idToken: null,
                accessToken: null,
                authenticationContext: authenticationContext,
                globalSessionExpiresAt: globalSessionExpiresAt,
                globalSessionState: session_state,
                clientId: clientId,
                scope: scope,
                acrValues: acrValues,
                maxAge: maxAge
              });
            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _processAuthResponse(_x2, _x3, _x4, _x5, _x6, _x7, _x8) {
        return _processAuthResponse2.apply(this, arguments);
      }
      return _processAuthResponse;
    }() // ======================== Private methods ================================
  }, {
    key: "_validateAuthResponse",
    value: function () {
      var _validateAuthResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(authResponse, state, nonce) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(state && authResponse.state !== state)) {
                _context3.next = 2;
                break;
              }
              throw new AuthenticationError("Invalid 'state' in received authorization response. Expected " + state + " but got " + authResponse.state + ". Response: " + JSON.stringify(authResponse));
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function _validateAuthResponse(_x9, _x10, _x11) {
        return _validateAuthResponse2.apply(this, arguments);
      }
      return _validateAuthResponse;
    }()
  }]);
  return CodeFlow;
}(AbstractAuthorizationFlow);
module.exports = CodeFlow;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var _require = __webpack_require__(9),
  AppClient = _require.AppClient;
var ClientCredentialsProvider = __webpack_require__(27);
var _require2 = __webpack_require__(5),
  AuthenticationError = _require2.AuthenticationError;
var AbstractAuthorizationFlow = __webpack_require__(29);
var CodeFlow = __webpack_require__(36);
var InteractionRequired = __webpack_require__(34);
var RESTORE_SESSION_FORCED = "forced";
var WINDOW = location.href.startsWith("about:") && window.frameElement ? parent : window;
var CSRF_COOKIE = new RegExp("uu.app.csrf=([^;]+)");

/**
 * Implementation of code flow with mitigation for thirdparty cookies.
 * (uses redirect for session restore, command for refresh and calltoken)
 */
var CodeFlowV2 = /*#__PURE__*/function (_CodeFlow) {
  _inherits(CodeFlowV2, _CodeFlow);
  var _super = _createSuper(CodeFlowV2);
  function CodeFlowV2(oauthClient, serviceName, redirectUri, appBaseUri) {
    var _this;
    _classCallCheck(this, CodeFlowV2);
    _this = _super.call(this, oauthClient, serviceName, redirectUri);
    _this._oauthClient = oauthClient;
    _this._serviceName = serviceName;
    _this._redirectUri = redirectUri;
    _this._appBaseUri = appBaseUri;
    _this._client = new AppClient();
    _this._doOnlyLocalSessionCheck = false;
    return _this;
  }
  _createClass(CodeFlowV2, [{
    key: "restoreSession",
    value: function () {
      var _restoreSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, scope) {
        var isAuthCallback, result, resultValid;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              isAuthCallback = sessionStorage.getItem("uu_app_oidc_auth_cb");
              sessionStorage.removeItem("uu_app_oidc_auth_cb");
              _context.next = 4;
              return this._restoreSessionViaAppSession(options, scope);
            case 4:
              result = _context.sent;
              resultValid = result && this._assertConstraints(result.claims, options, isAuthCallback);
              if (!(!resultValid && !isAuthCallback)) {
                _context.next = 10;
                break;
              }
              _context.next = 9;
              return this._resotreSessionViaIdpSession(options, scope);
            case 9:
              result = _context.sent;
            case 10:
              if (result) {
                _context.next = 16;
                break;
              }
              _context.next = 13;
              return this._oauthClient.getMetadata();
            case 13:
              _context.next = 15;
              return ClientCredentialsProvider.getClientId(this._serviceName);
            case 15:
              this._throwInteractionRequired();
            case 16:
              return _context.abrupt("return", result);
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function restoreSession(_x, _x2) {
        return _restoreSession.apply(this, arguments);
      }
      return restoreSession;
    }()
  }, {
    key: "checkSession",
    value: function () {
      var _checkSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(query) {
        var result;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!this._doOnlyLocalSessionCheck) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("return", this._isSessionValid() ? "unchanged" : "changed");
            case 4:
              _context2.next = 6;
              return _get(_getPrototypeOf(CodeFlowV2.prototype), "checkSession", this).call(this, query);
            case 6:
              result = _context2.sent;
              if (result === "unknown") {
                this._logger.warn("Switching global session check to application session check due to blocked thirdparty cookies.");
                this._doOnlyLocalSessionCheck = true;
                result = "unchanged";
              }
            case 8:
              return _context2.abrupt("return", result);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function checkSession(_x3) {
        return _checkSession.apply(this, arguments);
      }
      return checkSession;
    }()
  }, {
    key: "refreshSession",
    value: function () {
      var _refreshSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
        var scope,
          authResponseTime,
          claims,
          globalSessionExpiresAt,
          globalSessionState,
          clientId,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              scope = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;
              if (!this._isSessionValid()) {
                this._throwInteractionRequired();
              }
              authResponseTime = Date.now();
              _context3.prev = 3;
              _context3.next = 6;
              return this._client.post(this._appBaseUri + "oidc/extendSession");
            case 6:
              claims = _context3.sent.data;
              _context3.next = 16;
              break;
            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](3);
              if (!(_context3.t0.status && _context3.t0.status === 401)) {
                _context3.next = 15;
                break;
              }
              this._throwInteractionRequired(_context3.t0);
              _context3.next = 16;
              break;
            case 15:
              throw _context3.t0;
            case 16:
              this._assertConstraints(claims, options, true);
              globalSessionExpiresAt = authResponseTime + 1000 * claims.session_info.session_expires_in;
              globalSessionState = claims.session_info.session_state;
              clientId = claims.session_info.client_id;
              delete claims.session_info;
              delete claims.uuAppErrorMap;
              return _context3.abrupt("return", {
                claims: claims,
                globalSessionExpiresAt: globalSessionExpiresAt,
                globalSessionState: globalSessionState,
                clientId: clientId
              });
            case 23:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[3, 9]]);
      }));
      function refreshSession(_x4) {
        return _refreshSession.apply(this, arguments);
      }
      return refreshSession;
    }()
  }, {
    key: "getCallToken",
    value: function () {
      var _getCallToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options) {
        var scope,
          grantResult,
          expireAt,
          _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              scope = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : null;
              _context4.next = 3;
              return this._client.post(this._appBaseUri + "oidc/grantCallToken", {
                scope: scope
              });
            case 3:
              grantResult = _context4.sent.data;
              expireAt = Date.now() + grantResult.expires_in * 1000;
              return _context4.abrupt("return", {
                idToken: grantResult.id_token,
                accessToken: grantResult.access_token,
                expireAt: expireAt
              });
            case 6:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getCallToken(_x5) {
        return _getCallToken.apply(this, arguments);
      }
      return getCallToken;
    }()
  }, {
    key: "_restoreSessionViaAppSession",
    value: function () {
      var _restoreSessionViaAppSession2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(options, scope) {
        var authResponseTime, claims, globalSessionExpiresAt, globalSessionState, clientId, acrValues, maxAge, authenticationContext;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              this._logger.debug("Trying to restore session based on existing application session.");
              if (this._isSessionValid()) {
                _context5.next = 4;
                break;
              }
              this._logger.debug("Application session not found.");
              return _context5.abrupt("return", null);
            case 4:
              authResponseTime = Date.now();
              _context5.prev = 5;
              _context5.next = 8;
              return this._client.get(this._appBaseUri + "oidc/introspect", {
                _: Date.now()
              });
            case 8:
              claims = _context5.sent.data;
              _context5.next = 15;
              break;
            case 11:
              _context5.prev = 11;
              _context5.t0 = _context5["catch"](5);
              this._logger.debug("Restoring of session based on existing application session failed.", _context5.t0);
              return _context5.abrupt("return", null);
            case 15:
              if (!(!claims || !claims.session_info)) {
                _context5.next = 18;
                break;
              }
              this._logger.debug("Application session not found.");
              return _context5.abrupt("return", null);
            case 18:
              globalSessionExpiresAt = authResponseTime + 1000 * claims.session_info.session_expires_in;
              globalSessionState = claims.session_info.session_state;
              clientId = claims.session_info.client_id;
              delete claims.session_info;
              delete claims.uuAppErrorMap;
              acrValues = options.acrValues || this._defaultAcrValues;
              maxAge = options.maxAge || this._defaultMaxAge;
              authenticationContext = sessionStorage.getItem("uu_app_oidc_auth_ctx");
              if (authenticationContext) {
                authenticationContext = JSON.parse(authenticationContext);
                sessionStorage.removeItem("uu_app_oidc_auth_ctx");
              }
              return _context5.abrupt("return", {
                claims: claims,
                idToken: null,
                accessToken: null,
                authenticationContext: authenticationContext,
                globalSessionExpiresAt: globalSessionExpiresAt,
                globalSessionState: globalSessionState,
                clientId: clientId,
                scope: scope,
                acrValues: acrValues,
                maxAge: maxAge
              });
            case 28:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[5, 11]]);
      }));
      function _restoreSessionViaAppSession(_x6, _x7) {
        return _restoreSessionViaAppSession2.apply(this, arguments);
      }
      return _restoreSessionViaAppSession;
    }()
  }, {
    key: "_resotreSessionViaIdpSession",
    value: function () {
      var _resotreSessionViaIdpSession2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options, scope) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              this._logger.debug("Restoring session by redirection to configured identity provider.");
              // We have to load metadata, else redirect will not work
              // due to requirement of metadata being available locally
              _context6.next = 3;
              return this._oauthClient.getMetadata();
            case 3:
              options = _objectSpread(_objectSpread({}, options), {}, {
                usePopup: false,
                prompt: "none",
                noIframe: true
              });
              if (AbstractAuthorizationFlow.getRestoreSessionOnLoad() === RESTORE_SESSION_FORCED) {
                delete options.prompt;
              }
              // Store current referrer to provide it after redirect
              sessionStorage.setItem("uu_app_oidc_auth_referrer", document.referrer);
              return _context6.abrupt("return", this.authenticate(options, scope));
            case 7:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function _resotreSessionViaIdpSession(_x8, _x9) {
        return _resotreSessionViaIdpSession2.apply(this, arguments);
      }
      return _resotreSessionViaIdpSession;
    }()
  }, {
    key: "_assertConstraints",
    value: function () {
      var _assertConstraints2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(claims, options, throwError) {
        var acrValues, maxAge;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              acrValues = options.acrValues || this._defaultAcrValues;
              if (!(acrValues && !acrValues.includes(claims.acr))) {
                _context7.next = 7;
                break;
              }
              if (!throwError) {
                _context7.next = 6;
                break;
              }
              this._throwInteractionRequired();
              _context7.next = 7;
              break;
            case 6:
              return _context7.abrupt("return", false);
            case 7:
              maxAge = options.maxAge || this._defaultMaxAge;
              if (!(maxAge && (claims.auth_time + maxAge) * 1000 < Date.now())) {
                _context7.next = 14;
                break;
              }
              if (!throwError) {
                _context7.next = 13;
                break;
              }
              this._throwInteractionRequired();
              _context7.next = 14;
              break;
            case 13:
              return _context7.abrupt("return", false);
            case 14:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function _assertConstraints(_x10, _x11, _x12) {
        return _assertConstraints2.apply(this, arguments);
      }
      return _assertConstraints;
    }()
  }, {
    key: "_isSessionValid",
    value: function _isSessionValid() {
      var csrfToken = (CSRF_COOKIE.exec(WINDOW.document.cookie) || [])[1];
      if (!csrfToken) {
        return false;
      }
      var tokenParts = csrfToken.split(".");
      if (tokenParts.length === 3) {
        // Token with expiration (newer version of backend)
        return Number(tokenParts[0]) * 1000 > Date.now() ? true : false;
      } else {
        // Token without expiration (older version of backend)
        return true;
      }
    }
  }, {
    key: "_throwInteractionRequired",
    value: function _throwInteractionRequired() {
      var cause = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var error = new InteractionRequired("Authentication Request cannot be completed without displaying a user interface for End-User interaction.", cause);
      error.code = "interaction_required";
      throw error;
    }
  }]);
  return CodeFlowV2;
}(CodeFlow);
module.exports = CodeFlowV2;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var _require = __webpack_require__(5),
  AuthenticationError = _require.AuthenticationError;
var ClientCredentialsProvider = __webpack_require__(27);
var ImplicitFlow = __webpack_require__(35);

/**
 * Requires os8Token when authenticating, the token is sent to special endpoint and otherwise it's
 * exactly the same as ImplicitFlow.
 */
var Os8Flow = /*#__PURE__*/function (_ImplicitFlow) {
  _inherits(Os8Flow, _ImplicitFlow);
  var _super = _createSuper(Os8Flow);
  function Os8Flow(oauthClient, serviceName, redirectUri) {
    _classCallCheck(this, Os8Flow);
    return _super.call(this, oauthClient, serviceName, redirectUri, null);
  }
  _createClass(Os8Flow, [{
    key: "authenticate",
    value: function () {
      var _authenticate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        var scope,
          os8Token,
          clientId,
          urlParams,
          urlParamsParts,
          authUri,
          authResponse,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              scope = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
              os8Token = options.os8Token;
              if (os8Token) {
                _context.next = 4;
                break;
              }
              throw new AuthenticationError("Authentication using Os8Flow requires option 'os8Token' passed to the authentication call.");
            case 4:
              _context.next = 6;
              return ClientCredentialsProvider.getClientId(this._serviceName);
            case 6:
              clientId = _context.sent;
              urlParams = {
                subject_token: os8Token,
                response_type: "id_token",
                client_id: clientId,
                redirect_uri: this._redirectUri
              };
              urlParamsParts = Object.keys(urlParams).filter(function (k) {
                return urlParams[k] != null;
              }).map(function (k) {
                return encodeURIComponent(k) + "=" + encodeURIComponent(urlParams[k] + "");
              });
              authUri = this._oauthClient.getServiceUri().replace(/\/*$/, "/") + "exchangeOs8Token" + "?" + urlParamsParts.join("&");
              _context.next = 12;
              return this.sendRequest(authUri);
            case 12:
              authResponse = _context.sent;
              _context.next = 15;
              return this._processAuthResponse(authResponse, null, null, scope, null, null, clientId);
            case 15:
              return _context.abrupt("return", _context.sent);
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function authenticate(_x) {
        return _authenticate.apply(this, arguments);
      }
      return authenticate;
    }()
  }]);
  return Os8Flow;
}(ImplicitFlow);
module.exports = Os8Flow;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(8),
  LoggerFactory = _require.LoggerFactory;
var SessionStateChangeNotifier = /*#__PURE__*/function () {
  function SessionStateChangeNotifier(authnFlow, sessionCheckInterval, clientId, getSessionStateFn) {
    _classCallCheck(this, SessionStateChangeNotifier);
    this._authnFlow = authnFlow;
    this._enabled = true;
    this._sessionCheckInterval = sessionCheckInterval;
    this._clientId = clientId;
    this._getSessionStateFn = getSessionStateFn;
    this._listeners = [];
    this._unknownStateListeners = [];
    this._notifyUnknownState = true;
    this._logger = LoggerFactory.get("uuapp.oidc.internal.SessionStateChangeNotifier");
    // start checking
    this._stateCheckInterval = setInterval(this._checkState.bind(this), this._sessionCheckInterval * 1000);
  }
  _createClass(SessionStateChangeNotifier, [{
    key: "enable",
    value: function enable() {
      this._enabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      this._enabled = false;
    }
  }, {
    key: "onStateChange",
    value: function onStateChange(listenerFn) {
      var _this = this;
      this._listeners.push(listenerFn);
      return function () {
        // return function for unregistering
        var idx = _this._listeners.indexOf(listenerFn);
        if (idx != -1) _this._listeners.splice(idx, 1);
        return idx != -1;
      };
    }
  }, {
    key: "onStateUnknown",
    value: function onStateUnknown(listenerFn) {
      var _this2 = this;
      this._unknownStateListeners.push(listenerFn);
      return function () {
        // return function for unregistering
        var idx = _this2._unknownStateListeners.indexOf(listenerFn);
        if (idx != -1) _this2._unknownStateListeners.splice(idx, 1);
        return idx != -1;
      };
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this._destroyed) return;
      this._destroyed = true;
      if (this._stateCheckInterval) clearInterval(this._stateCheckInterval);
      delete this._stateCheckInterval;
      this._listeners = [];
      this._unknownStateListeners = [];
      this._notifyUnknownState = true;
    }
  }, {
    key: "_checkState",
    value: function () {
      var _checkState2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var sessionState, query, sessionStateResult;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this._enabled) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              sessionState = this._getSessionStateFn(); // skip if:
              // a) we have no session state (and we don't really need to get info that the user became logged in due to login in different tab)
              // b) unknown session state (e.g. current token was provided directly, instead of via login in browser tab)
              if (sessionState) {
                _context.next = 5;
                break;
              }
              return _context.abrupt("return");
            case 5:
              query = this._clientId + " " + sessionState;
              this._logger.debug("Checking session state.");
              _context.next = 9;
              return this._authnFlow.checkSession(query);
            case 9:
              sessionStateResult = _context.sent;
              if (sessionStateResult === "changed") {
                this._logger.debug("Received session state change notification (message: '".concat(sessionStateResult, "')."));
                this._notifyUnknownState = true;
                this._listeners.forEach(function (fn) {
                  return fn();
                });
              } else if (sessionStateResult === "unknown") {
                this._logger.debug("Received session state change notification (message: '".concat(sessionStateResult, "')."));
                if (this._notifyUnknownState) {
                  this._logger.debug("Propagating info about '".concat(sessionStateResult, "' session state."));
                  this._unknownStateListeners.forEach(function (fn) {
                    return fn();
                  });
                  this._notifyUnknownState = false;
                }
              } else {
                this._notifyUnknownState = true;
              }
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _checkState() {
        return _checkState2.apply(this, arguments);
      }
      return _checkState;
    }()
  }]);
  return SessionStateChangeNotifier;
}();
module.exports = SessionStateChangeNotifier;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(7),
  Config = _require.Config,
  Digest = _require.Digest;
var _require2 = __webpack_require__(8),
  LoggerFactory = _require2.LoggerFactory;
var OidcSession = __webpack_require__(25);
var ExternalCallTokenProvider = __webpack_require__(41);
var Dom = __webpack_require__(28);
var STORE_PREFIX = "uu_app_oidc_providers_";
var CONFIG_PREFIX = "uu_app_oidc_providers_";
var JWT_CLAIM_EXP = "exp";

// TODO Constant for workaround to allow sending of word values to G01
var G02_ACR_VALUES_OLD = ["none", "low", "medium", "high", "veryHigh"];
var G02_ACR_VALUES = ["none", "low", "standard", "high", "veryHigh"];
var logger = LoggerFactory.get("uuapp.oidc.Session");
var isNestedUri = function isNestedUri(nestedUri, rootUri) {
  var nestedUriElements = nestedUri.toString().split("/");
  var rootUriElements = rootUri.toString().split("/");
  if (rootUriElements.length > nestedUriElements.length) {
    return false;
  }
  for (var i = 0; i < rootUriElements.length; i++) {
    if (rootUriElements[i] !== nestedUriElements[i]) {
      return false;
    }
  }
  return true;
};
var BrowserSession = /*#__PURE__*/function () {
  function BrowserSession() {
    _classCallCheck(this, BrowserSession);
  }
  _createClass(BrowserSession, null, [{
    key: "from",
    value: function from(session, authenticationContext, expiresAt, state, authnService) {
      if (!session) return session;

      // Cache base uri without trailing slashes (to be used when call token is requested)
      session._appBaseUri = Dom.appBaseUri.replace(/\/$/, "");

      // Add frontend specific method for returning authentication context
      session._authnCtx = authenticationContext || null;
      session.getAuthenticationContext = function () {
        return this._authnCtx;
      }.bind(session);

      // Add frontend specific method for returning session expiration time
      session._expiresAt = expiresAt || null;
      session.getExpiresAt = function () {
        return this._expiresAt;
      }.bind(session);

      // Add frontend specific method for returning session state
      session._state = state || null;
      session.getState = function () {
        return this._state;
      }.bind(session);

      // Add frontend specific field authnService required by ExternalCallTokenProvider
      Object.defineProperty(session, "_authnService", {
        get: function get() {
          return authnService;
        },
        enumerable: false
      });

      // Override session.getCallTokenScope in order to provide
      // valid scope also for application using aliases
      session._origGetCallTokenScope = session.getCallTokenScope.bind(session);
      session.getCallTokenScope = function () {
        var uri = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!uri) {
          return null;
        }
        var scope;
        if (isNestedUri(uri, this._appBaseUri)) {
          scope = this._appBaseUri;
        } else {
          scope = this._origGetCallTokenScope(uri, opts);
        }
        return scope;
      }.bind(session);

      // Override session.getCallToken to support providing of tokens
      // for external calls without use of token exchange which is not
      // possible to realize on frontend
      session.getCallToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var scope,
          opts,
          token,
          callTokenType,
          cfgKey,
          excludeAuthType,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              scope = _args.length > 0 && _args[0] !== undefined ? _args[0] : null;
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              if (!(scope == null || !isNestedUri(scope, this._appBaseUri))) {
                _context.next = 8;
                break;
              }
              _context.next = 5;
              return ExternalCallTokenProvider.getCallToken(session, scope, opts);
            case 5:
              token = _context.sent;
              _context.next = 11;
              break;
            case 8:
              callTokenType = opts ? opts.callTokenType : null;
              if (!callTokenType) {
                cfgKey = "".concat(this._configPrefix, "call_token_type");
                callTokenType = Config.getString(cfgKey);
              }
              if (callTokenType === "idToken") {
                token = this._idToken;
              } else if (callTokenType === "accessToken") {
                token = this._accessToken;
              } else if (!callTokenType) {
                token = this._idToken || this._accessToken;
              }
            case 11:
              if (!token) {
                _context.next = 20;
                break;
              }
              excludeAuthType = opts ? opts.excludeAuthenticationType : false;
              if (!(excludeAuthType === true)) {
                _context.next = 17;
                break;
              }
              return _context.abrupt("return", token);
            case 17:
              return _context.abrupt("return", "Bearer ".concat(token));
            case 18:
              _context.next = 21;
              break;
            case 20:
              return _context.abrupt("return", null);
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      })).bind(session);

      // Override session.actAs() to invoke authentication with login hint
      // in order to switch user on frontend.
      session.actAs = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(uuIdentity) {
          var scope,
            opts,
            _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                scope = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
                opts = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};
                if (scope != null && typeof scope !== "string" && !Array.isArray(scope)) {
                  opts = scope;
                  scope = null;
                }
                opts = _objectSpread({}, opts);
                delete opts.prompt;
                opts.loginHint = uuIdentity;
                if (opts.usePopup == null) {
                  opts.usePopup = false;
                }
                this.removeFromCache();
                _context2.next = 10;
                return this._authnService.authenticate(opts, scope);
              case 10:
                return _context2.abrupt("return", _context2.sent);
              case 11:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }();

      // Override session.close() to perform logout in browser environment
      session.close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              this.removeFromCache();
              if (!this._authenticated) {
                _context3.next = 15;
                break;
              }
              _context3.prev = 2;
              _context3.next = 5;
              return session._authnService._authnFlow.endSession(session);
            case 5:
              if (typeof this._onCloseListener === "function") {
                this._onCloseListener(this);
              }
              session._authenticated = false;
              session._idToken = null;
              session._accessToken = null;
              _context3.next = 15;
              break;
            case 11:
              _context3.prev = 11;
              _context3.t0 = _context3["catch"](2);
              logger.warn("Logout finished but session might not be cancelled - server responded with unexpected callback.", _context3.t0);
              // Invoke explicit session check which will cause logout in case session was successfully canceled
              session._authnService.checkSession();
            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[2, 11]]);
      })).bind(session);

      // Add frontend specific method to check if session matches given constraints
      session.matches = function (acrValues, maxAge) {
        var minAuthenticationLevelOfAssurance;
        if (acrValues) {
          var supportedValues = this._supportedAcrValues;
          // TODO Workaround for renaming of "medium" acrValue on G02 server
          var requestedValuesStr = acrValues.toString();
          if (supportedValues.includes("medium")) {
            requestedValuesStr = requestedValuesStr.replace("standard", "medium");
          } else if (supportedValues.includes("standard")) {
            requestedValuesStr = requestedValuesStr.replace("medium", "standard");
          }
          // ...end of workaround
          // Transform all values to number and find minimum (so we can delegate
          // call to session.assertTrustiness)
          var requestedValues = requestedValuesStr.split(" ");
          var transformedValues = [];
          requestedValues.forEach(function (requestedValue) {
            var transformedValue = Number(requestedValue);
            if (isNaN(transformedValue)) {
              transformedValue = supportedValues.indexOf(requestedValue);
              // TODO Workaround for checking word values against G01
              if (transformedValue < 0) {
                transformedValue = G02_ACR_VALUES.indexOf(requestedValue);
              }
              if (transformedValue < 0) {
                transformedValue = G02_ACR_VALUES_OLD.indexOf(requestedValue);
              }
              // ...end of workaround
            }

            if (transformedValue >= 0) {
              transformedValues.push(transformedValue);
            }
          });
          minAuthenticationLevelOfAssurance = Math.min.apply(Math, transformedValues);
        }
        var maxAuthenticationAge;
        if (maxAge) {
          maxAuthenticationAge = maxAge;
        }
        try {
          this.assertTrustiness({
            minAuthenticationLevelOfAssurance: minAuthenticationLevelOfAssurance,
            maxAuthenticationAge: maxAuthenticationAge
          });
          return true;
        } catch (e) {
          return false;
        }
      }.bind(session);

      // Add frontend specific method to store session to session store
      session.storeToCache = function () {
        var clientId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var sessionData = {
          attributes: this._attributes,
          acrValues: this._supportedAcrValues,
          idToken: this._idToken,
          acccessToken: this._accessToken,
          authnCtx: this._authnCtx,
          expiresAt: this._expiresAt,
          state: this._state,
          authConstraints: this._authConstraints,
          userAgent: Digest.sha1(navigator.userAgent)
        };
        var storeKey = "".concat(STORE_PREFIX).concat(this._serviceName, "_session");
        if (clientId) {
          storeKey += "_".concat(Digest.sha1(clientId));
        }
        sessionStorage.setItem(storeKey, JSON.stringify(sessionData));
      }.bind(session);

      // Add frontend specific method to remove session from session store
      session.removeFromCache = function () {
        var storeKey = "".concat(STORE_PREFIX).concat(this._serviceName, "_session");
        Object.keys(sessionStorage).forEach(function (key) {
          if (key && key.toString().startsWith(storeKey)) {
            sessionStorage.removeItem(key);
          }
        });
      }.bind(session);
      return session;
    }
  }, {
    key: "loadFromCache",
    value: function loadFromCache(authnService) {
      var clientId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var serviceName = authnService.getServiceName();
      var storeKey = "".concat(STORE_PREFIX).concat(serviceName, "_session");
      if (clientId) {
        storeKey += "_".concat(Digest.sha1(clientId));
      }
      var sessionData = sessionStorage.getItem(storeKey);
      if (!sessionData) {
        return null;
      }
      try {
        sessionData = JSON.parse(sessionData);
        var now = Date.now() / 1000;
        var tokenExpiresAt = sessionData.attributes[JWT_CLAIM_EXP];
        var tokenLeeway = Config.getNumber(CONFIG_PREFIX + serviceName + "_token_refresh_leeway");
        if (tokenLeeway == null) tokenLeeway = 5 * 60;
        if (sessionData.expiresAt && sessionData.expiresAt <= now || tokenExpiresAt && tokenExpiresAt - tokenLeeway <= now) {
          logger.warn("Cached session for ".concat(serviceName, " is expired."));
          sessionStorage.removeItem(storeKey);
          return null;
        }
        if (sessionData.userAgent != Digest.sha1(navigator.userAgent)) {
          logger.warn("UserAgent does not match on cached session for service ".concat(serviceName, "."));
          sessionStorage.removeItem(storeKey);
          return null;
        }
        var oauthClient = authnService._oauthClient;
        var session = new OidcSession(serviceName, oauthClient, sessionData.acrValues, sessionData.attributes, sessionData.idToken, sessionData.acccessToken);
        session._authConstraints = sessionData.authConstraints;
        return BrowserSession.from(session, sessionData.authnCtx, sessionData.expiresAt, sessionData.state, authnService);
      } catch (e) {
        logger.error("Unable to restore cached session for ".concat(serviceName, "."), e);
        return null;
      }
    }
  }]);
  return BrowserSession;
}();
module.exports = BrowserSession;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(7),
  Config = _require.Config;
var _require2 = __webpack_require__(8),
  LoggerFactory = _require2.LoggerFactory;
var CONFIG_PREFIX = "uu_app_oidc_providers_";
var DEFAULT_TOKEN_TIME_LEEWAY = 5 * 60;

/**
 * Component providing tokens for external calls
 * (call to URLs outside of current application scope)
 */
var ExternalCallTokenProvider = /*#__PURE__*/function () {
  /**
   * Creates new external call token provider.
   * @param {Session} initSession Instance of current session in which scope we are requesting token.
   * @param {String} callUri Call URI for which to provide token
   */
  function ExternalCallTokenProvider(initSession, callUri) {
    var _this = this;
    _classCallCheck(this, ExternalCallTokenProvider);
    this._serviceName = initSession.getServiceName();
    this._callUri = callUri;
    this._configPrefix = "".concat(CONFIG_PREFIX).concat(this._serviceName, "_");
    this._tokenTimeLeeway = Config.getNumber("".concat(this._configPrefix, "token_time_leeway"), false) || DEFAULT_TOKEN_TIME_LEEWAY;
    this._logger = LoggerFactory.get("uuapp.oidc.ExternalCallTokenProvider");
    this._authnFlow = initSession._authnService._authnFlow;
    this._runningPromise = null;
    this._idToken = null;
    this._accessToken = null;
    this._expireAt = null;
    initSession._authnService.addListener("sessionChanged", function () {
      _this._idToken = null;
      _this._accessToken = null;
      _this._expireAt = null;
    });
  }
  _createClass(ExternalCallTokenProvider, [{
    key: "_getCallToken",
    value: function () {
      var _getCallToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var opts,
          authOpts,
          _yield$this$_runningP,
          idToken,
          accessToken,
          claims,
          expireAt,
          token,
          callTokenType,
          cfgKey,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              if (!this._isExpired()) {
                _context.next = 24;
                break;
              }
              if (!this._runningPromise) {
                this._logger.debug("Requesting new call token for ".concat(this._callUri));
                authOpts = {
                  prompt: "none",
                  usePopup: false
                };
                if (this._authnFlow.getCallToken) {
                  this._runningPromise = this._authnFlow.getCallToken(authOpts, this._callUri);
                } else {
                  this._runningPromise = this._authnFlow.authenticate(authOpts, this._callUri);
                }
              }
              _context.prev = 3;
              _context.next = 6;
              return this._runningPromise;
            case 6:
              _yield$this$_runningP = _context.sent;
              idToken = _yield$this$_runningP.idToken;
              accessToken = _yield$this$_runningP.accessToken;
              claims = _yield$this$_runningP.claims;
              expireAt = _yield$this$_runningP.expireAt;
              this._idToken = idToken;
              this._accessToken = accessToken;
              if (expireAt) {
                this._expireAt = expireAt;
              } else {
                this._expireAt = claims.exp * 1000;
              }
              this._logger.debug("Call token for ".concat(this._callUri, " received"));
              _context.next = 21;
              break;
            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](3);
              this._logger.error("Unable to get call token for ".concat(this._callUri), _context.t0);
              return _context.abrupt("return", null);
            case 21:
              _context.prev = 21;
              this._runningPromise = null;
              return _context.finish(21);
            case 24:
              token = null;
              callTokenType = opts ? opts.callTokenType : null;
              if (!callTokenType) {
                cfgKey = "".concat(this._configPrefix, "call_token_type");
                callTokenType = Config.getString(cfgKey);
              }
              if (callTokenType === "idToken") {
                token = this._idToken;
              } else if (callTokenType === "accessToken") {
                token = this._accessToken;
              } else if (!callTokenType) {
                token = this._idToken || this._accessToken;
              }
              return _context.abrupt("return", token);
            case 29:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3, 17, 21, 24]]);
      }));
      function _getCallToken() {
        return _getCallToken2.apply(this, arguments);
      }
      return _getCallToken;
    }()
  }, {
    key: "_isExpired",
    value: function _isExpired() {
      if (!this._expireAt) {
        return true;
      }
      return Date.now() >= this._expireAt - this._tokenTimeLeeway * 2;
    }
  }], [{
    key: "getCallToken",
    value:
    /**
     * Returns token to be used by client to call functionality provided by other application server.
     * @param {Session} initSession Instance of current session in which scope we are requesting token.
     * @param {String|URI} callUri URI of called functionality.
     * @param {Object} opts Call token options.
     * @param {boolean|null} opts.callTokenType Variant of call token (possible values depends on actual authentication implementation).
     * @returns {Promise<String>} Call token
     */
    function () {
      var _getCallToken3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(initSession, callUri, opts) {
        var serviceName, providerKey, provider;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              serviceName = initSession.getServiceName();
              if (!(!serviceName || !initSession._oauthClient)) {
                _context2.next = 3;
                break;
              }
              return _context2.abrupt("return", null);
            case 3:
              callUri = callUri ? callUri.toString() : "";
              providerKey = "".concat(serviceName, "|").concat(callUri);
              provider = this._providers[providerKey];
              if (!provider) {
                provider = new this(initSession, callUri);
                this._providers[providerKey] = provider;
              }
              return _context2.abrupt("return", provider._getCallToken(opts));
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getCallToken(_x, _x2, _x3) {
        return _getCallToken3.apply(this, arguments);
      }
      return getCallToken;
    }()
  }]);
  return ExternalCallTokenProvider;
}();
ExternalCallTokenProvider._providers = {};
module.exports = ExternalCallTokenProvider;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// TODO Remove when compatibility with uu_oidcg01 is no longer needed.
var SessionWrapper = /*#__PURE__*/function () {
  function SessionWrapper() {
    _classCallCheck(this, SessionWrapper);
  }
  _createClass(SessionWrapper, null, [{
    key: "wrapClass",
    value:
    /**
     * Modifies Session class (API) to be compatible with uu_oidcg01's Session.
     * @param {*} session
     */
    function wrapClass(Session, AuthenticationService) {
      var oidcg01Session;
      Object.defineProperty(Session, "currentSession", {
        get: function get() {
          if (!oidcg01Session) oidcg01Session = SessionWrapper.initG01Session(Session, AuthenticationService);
          return oidcg01Session;
        }
      });
      Object.defineProperty(Session, "initComplete", {
        get: function get() {
          return AuthenticationService._onPageLoadFinished;
        }
      });
      Object.defineProperty(Session, "initPromise", {
        get: function get() {
          return AuthenticationService._onPageLoad().then(function (session) {
            if (!oidcg01Session) oidcg01Session = SessionWrapper.initG01Session(Session, AuthenticationService);
            return oidcg01Session;
          });
        }
      });
      return Session;
    }
  }, {
    key: "initG01Session",
    value: function initG01Session(Session, AuthenticationService) {
      var session = Session._createEmptySession(); // in case user of legacy API uses "obj instanceof Session" expression

      Object.defineProperty(session, "initComplete", {
        get: function get() {
          return AuthenticationService._onPageLoadFinished;
        }
      });
      Object.defineProperty(session, "initPromise", {
        get: function get() {
          return AuthenticationService._onPageLoad().then(function () {
            return session;
          });
        }
      });

      // NOTE In optimal case this wrapper would always use AuthenticationService.getCurrentSession().
      // However that's not possible if we're finishing session restore because the "sessionChanged" event
      // is triggerred sooner than AuthnService._primaryProvider gets updated. So if an app uses
      // e.g. getIdentity() inside of the sessionChanged event handler, we would forward it to AS.getCurrentSession()
      // which would return empty session / session from not-yet-updated _primaryProvider.
      // => during events use the g02 session instance which was sent to the event, otherwise use getCurrentSession()
      var runningG02Session = null;
      var getG02Session = function getG02Session() {
        return runningG02Session || AuthenticationService.getCurrentSession();
      };
      session.getIdentity = function () {
        var g02Session = getG02Session();
        var identity = g02Session.getIdentity();
        if (!identity) return identity;
        identity.id = g02Session.getAttribute("sub");
        identity.name = identity.getName();
        identity.email = g02Session.getAttribute("email");
        identity.uuIdentity = identity.getUuIdentity();
        identity.levelOfAssurance = identity.getLevelOfAssurance();
        identity.loginLevelOfAssurance = g02Session.getAuthenticationLevelOfAssurance();
        return identity;
      };
      session.getClaims = function () {
        return getG02Session()._attributes;
      };
      session.getCallToken = function () {
        var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (typeof scope === "string" || Array.isArray(scope)) {
          return getG02Session().getCallToken(scope, opts);
        } else {
          // If scope was not defined, return legacy value
          var _session = getG02Session();
          return {
            token: _session._idToken || _session._accessToken,
            tokenType: _session._idToken ? "Bearer" : null
          };
        }
      };
      session.getCallTokenScope = function () {
        var uri = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return getG02Session().getCallTokenScope(uri, opts);
      };
      session.isExpiring = function () {
        return AuthenticationService.isSessionExpiring();
      };
      session.isAuthenticated = function () {
        return getG02Session().isAuthenticated();
      };
      session.login = function (options) {
        var opts = _objectSpread({}, options);
        var authnSvcOpts = {};
        if (opts.access_token && opts.token_type_hint === "urn:ietf:params:oauth:token-type:jwt-uuos8") {
          authnSvcOpts = {
            os8Token: opts.access_token
          };
          delete opts.access_token;
          delete opts.token_type_hint;
        }
        Object.assign(authnSvcOpts, opts);
        return AuthenticationService.authenticate(authnSvcOpts).then(function () {
          return session;
        });
      };
      session.logout = function () {
        return getG02Session().close();
      };
      var _legacyListeners = {};
      session.addListener = function (eventType, listenerFn) {
        if (eventType === "identityChange") eventType = "sessionChanged";
        var unregFn = AuthenticationService.addListener(eventType, function (_ref) {
          var type = _ref.type,
            data = _ref.data;
          var origRunningG02Session = runningG02Session;
          if (data instanceof Session) runningG02Session = data;
          try {
            var g01Type = type;
            var g01Data = data instanceof Session ? session : data;
            if (type === "sessionChanged") {
              g01Type = "identityChange";
              g01Data = session.getIdentity();
            }
            var legacyEvent = {
              type: g01Type,
              data: g01Data
            };
            return listenerFn(legacyEvent);
          } finally {
            runningG02Session = origRunningG02Session;
          }
        });
        var map = _legacyListeners[eventType];
        if (!map) map = _legacyListeners[eventType] = new Map();
        map.set(listenerFn, unregFn);
        return unregFn;
      };
      session.removeListener = function (eventType, listenerFn) {
        if (eventType === "identityChange") eventType = "sessionChanged";
        var map = _legacyListeners[eventType];
        var unregFn = map ? map.get(listenerFn) : null;
        if (!unregFn) return false;
        map.delete(listenerFn);
        return unregFn();
      };
      var _legacyIdentityChangeListeners = new Map();
      session.addIdentityChangeListener = function (listenerFn) {
        var unregFn = session.addListener("identityChange", function (e) {
          return listenerFn(e.data);
        });
        _legacyIdentityChangeListeners.set(listenerFn, unregFn);
        return unregFn;
      };
      session.removeIdentityChangeListener = function (listenerFn) {
        var unregFn = _legacyIdentityChangeListeners.get(listenerFn);
        if (!unregFn) return false;
        _legacyIdentityChangeListeners.delete(listenerFn);
        return unregFn();
      };
      session.getAuthenticationContext = function () {
        return getG02Session().getAuthenticationContext();
      };
      session._unwrap = function () {
        return getG02Session();
      };
      return session;
    }
  }]);
  return SessionWrapper;
}();
module.exports = SessionWrapper;

/***/ })
/******/ ]);
});